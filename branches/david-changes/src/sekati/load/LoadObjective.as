/** * @version 1.0 * @author David Dahlstroem | hello@daviddahlstroem.com * Copyright (C) 2009 David Dahlstroem. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */ package sekati.load {	import sekati.core.ICoreInterface;	import sekati.core.Resetable;	import sekati.events.LoadObjectiveEvent;	import sekati.events.WeakEventDispatcher;	import sekati.reflect.Stringifier;		import flash.events.TimerEvent;	import flash.utils.Timer;		/**	 * Allows you to set marks defining a point in a loading process.	 * <p>	 * A LoadObjective instance defines a custom loading progress allowing your application to react to	 * when a certain amount of data has loaded - complete files or partially.	 * </p>	 * Unlike the LoaderSequence the LoadObjective does not interfere with loaders, it is simply an indicator. Use	 * LoadObjective when you e.g. want your applicaiton to respond to when one or several file streams have reached a	 * a certain progress. 	 * 	 * TODO Thourough testing required!	 */		public class LoadObjective extends WeakEventDispatcher implements ICoreInterface, Resetable	{				private var _loaderMap:Array;				private var _progressMap:Array;				private var _timer:Timer;				/**		 * LoadObjective Constructor		 */				public function LoadObjective()		{			super(this);						reset();		}				/**		 * Indicates the average progress of all the loaders referenced by a LoadObjective instance		 * with regard to each loaders progress goal.		 */				public function get progress():Number		{						var p:Number = 0;						for(var i:int = 0; i< numLoaders; i++)			{								var loader:AbstractLoader = _loaderMap[i] as AbstractLoader;								var progressGoal:Number = _progressMap[i] as Number;								p += Math.min(loader.progress / progressGoal, 1);				 			}						return p / numLoaders;		}				/**		 * Indicates the number of loaders referenced by a LoadObjective instance.		 */				public function get numLoaders():uint		{			return _loaderMap.length;		}				/**		 * Adds a loader reference to the LoadObjective instance.		 * 		 * @param loader Loader reference.		 * @param progressGoal The progress goal of the loader reference. A loader only needs to reach this progress to be concidered fully loaded by a LoadObjective instance.		 */				public function addLoader(loader:AbstractLoader, progressGoal:Number = 1):AbstractLoader		{			_timer.start();						_loaderMap.push(loader);						_progressMap.push(Math.min(progressGoal, 1));						return loader;		}				/**		 * Removes a loader reference from a LoadObjective instance.		 */				public function removeLoader(loader:AbstractLoader):void		{			var index:uint = _loaderMap.indexOf(loader);						_loaderMap.splice(index, 1);						_progressMap.splice(index, 1);		}				/**		 * @inheritDoc		 */				public function destroy():void		{			_loaderMap = null;						_loaderMap = null;						_timer.stop();						_timer.removeEventListener(TimerEvent.TIMER, update);						_timer = null;		}				/**		 * @inheritDoc		 */				override public function toString():String		{			return Stringifier.stringify(this);		}				/**		 * @inheritDoc		 */				public function reset():void		{			if(_loaderMap) destroy();						_timer = new Timer(50);						_timer.addEventListener(TimerEvent.TIMER, update);						_loaderMap = [];						_progressMap = [];					}				private function update(e:TimerEvent):void		{			if(progress >= 1)			{				var validGoal:Boolean = true;								/*				 * Only dispatch LoadObjectiveEvent.OBJECTIVE_MET if all loaders with a progress goal of 1				 * are acctually loaded.				 */								for(var i:int = 0; i < _loaderMap.length; i++)				{					var loader:AbstractLoader = _loaderMap[i] as AbstractLoader;										var progressGoal:Number = _progressMap[i] as Number;										if(progressGoal >= 1 && !loader.loaded) validGoal = false;										break;					}								if(validGoal) dispatchEvent(new LoadObjectiveEvent(LoadObjectiveEvent.OBJECTIVE_MET));								_timer.stop();			}			else			{				if(hasEventListener(LoadObjectiveEvent.PROGRESS)) dispatchEvent(new LoadObjectiveEvent(LoadObjectiveEvent.PROGRESS));			}		}	}}