/** * @version 1.0 * @author David Dahlstroem | hello@daviddahlstroem.com *  * Copyright (C) 2009 David Dahlstroem. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.load {	import sekati.core.Cancelable;	import sekati.core.Cloneable;	import sekati.core.ICoreInterface;	import sekati.core.Resetable;	import sekati.events.FramePulse;	import sekati.events.LoaderEvent;	import sekati.media.VideoMetaData;		import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.getQualifiedClassName;		/**	 * VideoLoader provides a simple API for loading video files.	 */		public class VideoLoader extends AbstractLoader implements Loadable, Cloneable, Resetable, Cancelable, ICoreInterface 	{				private var _netConnection:NetConnection;				private var _netStream:NetStream;				private var _client:NetStreamClient;				private var _lastBytesLoaded:uint;				private var _metaData:VideoMetaData;				/**		 * VideoLoader constructor		 */				public function VideoLoader(sourceURL:String, loaderName:String = null)		{			super(sourceURL, loaderName);						reset();		}				/**		 * Indicates whether the video metadata is available.		 */				public function get hasMetaData():Boolean		{			return (_metaData != null);		}				/**		 * Returns the video meta data if it is available.		 * 		 * @return VideoMetaData instance.		 * @see sekati.media.VideoMetaData		 */				public function get metaData():VideoMetaData		{			return _metaData;		}				/**		 * @inheritDoc		 */				override public function load():void		{			_netStream.play(getURL());						_netStream.pause();						_netStream.seek(0);		}				/**		 * Returns the loader netStream.		 */				public function get netStream():NetStream		{			return data as NetStream;		}		/**		 * @inheritDoc		 */			override public function get data():*		{			return _netStream;		}				/**		 * @inheritDoc		 */				override public function clone():Object		{			return new VideoLoader(getURL(), name);		}				/**		 * @inheritDoc		 */				override public function reset():void		{						if(_netStream) setEventListeners(false);						_netConnection = new NetConnection();						_netConnection.connect(null);						_netStream = new NetStream(_netConnection);						_client = new NetStreamClient();						_client.onMetaData = handleMetaData;						_client.onXMPData = handleXMPData;						_netStream.client = _client;						_byteReference = new ByteReference(_netStream);						if(_netStream) setEventListeners(true);						_lastBytesLoaded = 0;						_metaData = null;		}				/**		 * @inheritDoc		 */				public function cancel():void		{			var success:Boolean = true;						try			{				_netStream.close();			}			catch(e:Error)			{				success = false;			}						if(success) dispatchLoadCancelEvent();		}				/**		 * @inheritDoc		 */				override public function destroy():void		{			cancel();						setEventListeners(false);						_netStream = null;						_netConnection = null;						_client.destroy();						_client = null;						_lastBytesLoaded = 0;		}				private function setEventListeners(add:Boolean):void		{			var method:String = add ? "addEventListener" : "removeEventListener";						_netStream[method](IOErrorEvent.IO_ERROR, dispatchIOErrorEvent);						_netStream[method](NetStatusEvent.NET_STATUS, handleNetStatusEvent);						if(add)			{				FramePulse.$.addFrameListener(resolveProgress);			}			else			{				FramePulse.$.removeFrameListener(resolveProgress);			}					}				private function resolveProgress(e:Event):void		{			if(bytesLoaded > 0 && bytesLoaded < bytesTotal)			{				dispatchLoadProgressEvent();			}						if(_lastBytesLoaded == 0 && bytesLoaded > 0) dispatchLoadStartEvent();						if(bytesLoaded >= bytesTotal && bytesTotal != 0)			{				FramePulse.$.removeFrameListener(resolveProgress);								dispatchLoadCompleteEvent();			}						_lastBytesLoaded = bytesLoaded;		}				private function handleNetStatusEvent(e:NetStatusEvent):void		{			switch(e.info["code"] as String)			{				default:					trace(e.info["code"]);				break;			}		}		private function handleMetaData(mData:Object):void		{			_metaData = new VideoMetaData();						for(var property:String in mData)			{				if(!_metaData.hasOwnProperty(property)) trace(_metaData, "Property " + property + "(" + getQualifiedClassName(mData[property]) + ") is not defined in VideoMetaData. Adding dynamic property.");								_metaData[property] = mData[property];			}						dispatchEvent(new LoaderEvent(LoaderEvent.META_DATA));		}				//TODO Add XMP data handler		private function handleXMPData(o:Object):void		{					}	}}internal class NetStreamClient{	public var onMetaData:Function;		public var onXMPData:Function;		public function destroy():void	{		onMetaData = null;	}}