/** * BitmapTransformer * @version 1.0.0 * @author pj ahlberg * Copyright (C) 2009  pj ahlberg. All Rights Reserved. */package {	import flash.display.*;	import flash.geom.Matrix;	import flash.geom.Point;	public class BitmapTransformer {		private var _dataWidth : Number;		private var _dataHeight : Number;		private var _vertsArray : Array;		private var _newVertsArray : Array;		private var _hDiv : int;		private var _vDiv : int;		public var _smoothOn : Boolean;		public function BitmapTransformer(w : Number,h : Number,hdiv : int = 5,vdiv : int = 5) {						_dataWidth = w;						_dataHeight = h;						_hDiv = hdiv;						_vDiv = vdiv;						_vertsArray = [];						_newVertsArray = [];						_smoothOn = false;						setVertices( );		}		/*		The next function sets a hDiv by vDiv mesh of vertices over a rectangular BitampData		object of dimensions dataWidth by dataHeight. Values for hDiv, vDiv, dataWidth, dataHeight		set by the constructor based on the parameters. 		 */		private function setVertices() : void {						var j : int;						var i : int;						var k : int;						var hStep : Number = _dataWidth / _hDiv;						var vStep : Number = _dataHeight / _vDiv;						for(j = 0; j <= _vDiv ;j++) {								_vertsArray[j] = [];								for(i = 0; i <= _hDiv ;i++) {										_vertsArray[j][i] = new Point( i * hStep, j * vStep );				}			}		}		/*		The next function calculates the corresponding vertices in a distorted		object. It will be used by the public mapBitmapData method.		 */		private function calcNewVerts(a : Point,b : Point,c : Point,d : Point) : void {						var i : int;						var j : int;						var verVecLeft : Array = [ d.x - a.x,d.y - a.y ];						var verVecRight : Array = [ c.x - b.x,c.y - b.y ];						var curVert : Point;						var curYCoeff : Number;						var curXCoeff : Number;						var curPointLeft : Point = new Point( );						var curPointRight : Point = new Point( );						var newVert : Point = new Point( );						for(j = 0; j <= _vDiv ;j++) {								_newVertsArray[j] = [];								for(i = 0; i <= _hDiv ;i++) {										_newVertsArray[j][i] = new Point( );										curVert = _vertsArray[j][i];										curYCoeff = curVert.y / _dataHeight;										curXCoeff = curVert.x / _dataWidth;										curPointLeft.x = a.x + curYCoeff * verVecLeft[0];										curPointLeft.y = a.y + curYCoeff * verVecLeft[1];										curPointRight.x = b.x + curYCoeff * verVecRight[0];										curPointRight.y = b.y + curYCoeff * verVecRight[1];										newVert.x = curPointLeft.x + (curPointRight.x - curPointLeft.x) * curXCoeff;										newVert.y = curPointLeft.y + (curPointRight.y - curPointLeft.y) * curXCoeff;										_newVertsArray[j][i].x = newVert.x;										_newVertsArray[j][i].y = newVert.y;				}			}		}		/*		The main method of the class, mapBitmapData, takes a BitmapData object of the dimensions		set by the constructor and maps it onto an arbitrary quadrangle. The method does it by		splitting each subrectangle of the distorted mesh into two triangles, and filling		each triangle with the distorted portion of the bitmap via beginBitmapFill. To use		beginBitmapFill, we need to draw the distorted triangle in some target container		in which the distorted bitmap will eventually reside. In our cube menu, each side		resides in a Sprite, side0, side1,...,side5. So for each side we draw in the corresponding		Sprite, side0, side1, and so on. 				The method takes the following parameters: a BitmapData object, Points that represent		vertices of the distortion quadrangle in a specific order: top-left, top-right,		bottom-right, bottom-left. The last parameter is the target object where drawing will take place.		It can be a Sprite, a Shape, or a MovieClip, depending on your application.				The reason why all of this works is that beginBitmapFill method takes a transform matrix as a possible		parameter. Any three points can be mapped onto any three points using an affine transformation;		that is, using a transform matrix. (Three yes, four no.) In the method's body,		we calculate the right transform matrix to apply to our bitmap at each step based on the positions of		the vertices of the original and of the distorted triangles.		 */		public function mapBitmapData(bd : BitmapData,topl : Point,topr : Point,botr : Point,botl : Point, cont : *) : void {						var i : int;						var j : int;						var curVertOld0 : Point = new Point( );						var curVertNew0 : Point = new Point( );						var curVertOld1 : Point = new Point( );						var curVertNew1 : Point = new Point( );						var curVertOld2 : Point = new Point( );						var curVertNew2 : Point = new Point( );						var finMat : Matrix = new Matrix( );						var linMat : Matrix = new Matrix( );						calcNewVerts( topl, topr, botr, botl );						for(j = 0; j < _vDiv ;j++) {								for(i = 0; i < _hDiv ;i++) {										curVertOld0.x = _vertsArray[j][i].x;										curVertOld0.y = _vertsArray[j][i].y;										curVertOld1.x = _vertsArray[j + 1][i].x;										curVertOld1.y = _vertsArray[j + 1][i].y;										curVertOld2.x = _vertsArray[j][i + 1].x;										curVertOld2.y = _vertsArray[j][i + 1].y;										curVertNew0.x = _newVertsArray[j][i].x;										curVertNew0.y = _newVertsArray[j][i].y;										curVertNew1.x = _newVertsArray[j + 1][i].x;										curVertNew1.y = _newVertsArray[j + 1][i].y;										curVertNew2.x = _newVertsArray[j][i + 1].x;										curVertNew2.y = _newVertsArray[j][i + 1].y;										finMat.tx = curVertOld0.x;										finMat.ty = curVertOld0.y;									finMat.a = 0;										finMat.b = (curVertOld1.y - curVertOld0.y) / _dataWidth;										finMat.c = (curVertOld2.x - curVertOld0.x) / _dataHeight;										finMat.d = 0;										linMat.a = (curVertNew1.x - curVertNew0.x) / _dataWidth;										linMat.b = (curVertNew1.y - curVertNew0.y) / _dataWidth;										linMat.c = (curVertNew2.x - curVertNew0.x) / _dataHeight;										linMat.d = (curVertNew2.y - curVertNew0.y) / _dataHeight;										linMat.tx = curVertNew0.x;										linMat.ty = curVertNew0.y;										finMat.invert( );										finMat.concat( linMat );									cont.graphics.beginBitmapFill( bd, finMat, false, _smoothOn );										cont.graphics.moveTo( curVertNew0.x, curVertNew0.y );										cont.graphics.lineTo( curVertNew1.x, curVertNew1.y );										cont.graphics.lineTo( curVertNew2.x, curVertNew2.y );										cont.graphics.lineTo( curVertNew0.x, curVertNew0.y );										cont.graphics.endFill( );										curVertOld0.x = _vertsArray[j + 1][i + 1].x;										curVertOld0.y = _vertsArray[j + 1][i + 1].y;										curVertOld1.x = _vertsArray[j][i + 1].x;										curVertOld1.y = _vertsArray[j][i + 1].y;										curVertOld2.x = _vertsArray[j + 1][i].x;										curVertOld2.y = _vertsArray[j + 1][i].y;										curVertNew0.x = _newVertsArray[j + 1][i + 1].x;										curVertNew0.y = _newVertsArray[j + 1][i + 1].y;										curVertNew1.x = _newVertsArray[j][i + 1].x;										curVertNew1.y = _newVertsArray[j][i + 1].y;										curVertNew2.x = _newVertsArray[j + 1][i].x;										curVertNew2.y = _newVertsArray[j + 1][i].y;										finMat.tx = curVertOld0.x;										finMat.ty = curVertOld0.y;									finMat.a = 0;										finMat.b = (curVertOld1.y - curVertOld0.y) / _dataWidth;										finMat.c = (curVertOld2.x - curVertOld0.x) / _dataHeight;										finMat.d = 0;										linMat.a = (curVertNew1.x - curVertNew0.x) / _dataWidth;										linMat.b = (curVertNew1.y - curVertNew0.y) / _dataWidth;										linMat.c = (curVertNew2.x - curVertNew0.x) / _dataHeight;										linMat.d = (curVertNew2.y - curVertNew0.y) / _dataHeight;										linMat.tx = curVertNew0.x;										linMat.ty = curVertNew0.y;										finMat.invert( );										finMat.concat( linMat );									cont.graphics.beginBitmapFill( bd, finMat, false, _smoothOn );										cont.graphics.moveTo( curVertNew0.x, curVertNew0.y );										cont.graphics.lineTo( curVertNew1.x, curVertNew1.y );										cont.graphics.lineTo( curVertNew2.x, curVertNew2.y );										cont.graphics.lineTo( curVertNew0.x, curVertNew0.y );										cont.graphics.endFill( );				}			}		}	}}