/** * ImageFlip * @version 1.0.0 * @author pj ahlberg * Copyright (C) 2009  pj ahlberg. All Rights Reserved. */package {	import caurina.transitions.Tweener;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Rectangle;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.geom.Point;	import sekati.display.CoreSprite;	import sekati.events.FramePulse;	import sekati.geom.TrigBase;	import sekati.log.Logger;	import BitmapTransformer;	/**	 * ImageFlip	 */	public class RotationPlane extends CoreSprite {		private var _bd0 : BitmapData;		private var _bd1 : BitmapData;				private var _bdTransform : BitmapTransformer;		private var _vertsArray : Array;		private var _facesArray : Array;		private var _numVertices : uint;		private var _numFaces : uint;		private var _boardSize : Number;		private var _spBoard : Sprite;		private var _shBack : Shape;		private var _spCube : Sprite;		private var _doRotate : Boolean;		private var _prevX : Number;		private var _prevY : Number;		private var _curTheta : Number;		private var _curPhi : Number;		private var _cubeSize : Number;				public var _rotationX:Number;		public var _rotationY:Number;				public var _fLen : Number;		public var _side0 : Sprite;		public var _side1 : Sprite;		public var _textureFront : Bitmap;		public var _textureBack : Bitmap;		public var _textureWidth : Number;		public var _textureHeight : Number;		/*		The constructor takes two parameters: an array of strings representing		local addresses of image files to be loaded and the size of the cube. 		Most commonly, the size of the cube would coincide with the size		of the square images loaded but it is not a requirement.		 */		public function RotationPlane(front : Bitmap,back : Bitmap) {			_textureFront = front;			_textureBack = back;						_textureWidth = _textureFront.width;			_textureHeight = _textureFront.height;						_cubeSize = front.height;		  			//The size of the board behind the cube. The board has listeners added to it			//that allow for better rotation properites. You can adjust colors of			//the background and border of the board using public methods defined below.			_boardSize = 2 * _cubeSize + 20;		  			//The constant responsible for perspective distortion. It is public; you can change			//its value from the outside of the class.			_fLen = 1000;						_spBoard = new Sprite( );			this.addChild( _spBoard );		  			_shBack = new Shape( );			_spBoard.addChild( _shBack );			_spCube = new Sprite( );			_spBoard.addChild( _spCube );			_spCube.x = _boardSize / 2;			_spCube.y = _boardSize / 2;			_side0 = new Sprite( );			_spCube.addChild( _side0 );			_side1 = new Sprite( );			_spCube.addChild( _side1 );						_side0.doubleClickEnabled = true;			_side1.doubleClickEnabled = true;			_doRotate = false;			_curTheta = 0;			_curPhi = 0;		  			drawBack( 0x00FF00, 0x333333, 0, _boardSize );		  						initApp( );		}		private function drawBack(b : Number,r : Number,t : Number,s : Number) : void {				_shBack.graphics.clear( );			_shBack.graphics.lineStyle( t, r );			_shBack.graphics.beginFill( b );			_shBack.graphics.drawRect( 0, 0, s, s );			_shBack.graphics.endFill( );		}				private function initApp() : void {									_bd0 = _textureFront.bitmapData.clone( );			_bd1 = _textureFront.bitmapData.clone( );	 			_bdTransform = new BitmapTransformer( _textureWidth, _textureHeight, 10, 10 );		  			_vertsArray = [];			_facesArray = [];			_numVertices = 8;			_numFaces = 2;			setVertices( );			setFaces( );			renderView( _curTheta, _curPhi );			setUpListeners( );		}				private function setVertices() : void {						_vertsArray[0] = [ 0,-_textureWidth / 2,_textureHeight / 2];			_vertsArray[1] = [ 0,_textureWidth / 2, _textureHeight / 2];			_vertsArray[2] = [ 0,_textureWidth / 2,-_textureHeight / 2 ];			_vertsArray[3] = [ 0,-_textureWidth / 2, -_textureHeight / 2 ];			_vertsArray[4] = [-1,-_textureWidth / 2, _textureHeight / 2 ];			_vertsArray[5] = [ -1,_textureWidth / 2, _textureHeight / 2 ];			_vertsArray[6] = [ -1,_textureWidth / 2, -_textureHeight / 2 ];			_vertsArray[7] = [ -1,-_textureWidth / 2, -_textureHeight / 2 ];		}		private function setFaces() : void {				_facesArray[0] = [ 0,1,2,3,_bd0 ];			_facesArray[1] = [ 7,6,5,4,_bd1 ];					}		private function setUpListeners() : void {					_spBoard.addEventListener( MouseEvent.ROLL_OUT, boardOut );			_spBoard.addEventListener( MouseEvent.MOUSE_MOVE, boardMove );			_spBoard.addEventListener( MouseEvent.MOUSE_DOWN, boardDown );			_spBoard.addEventListener( MouseEvent.MOUSE_UP, boardUp );			_side0.addEventListener( MouseEvent.DOUBLE_CLICK, side0Clicked );			_side1.addEventListener( MouseEvent.DOUBLE_CLICK, side1Clicked );				}		private function boardOut(e : MouseEvent) : void {						_doRotate = false;		}		private function boardDown(e : MouseEvent) : void {									_prevX = _spBoard.mouseX;			_prevY = _spBoard.mouseY;							_doRotate = true;		}		private function boardUp(e : MouseEvent) : void {						_doRotate = false;		}		private function boardMove(e : MouseEvent) : void {		 			var locX : Number = _prevX;			var locY : Number = _prevY;					if(_doRotate) {								_prevX = _spBoard.mouseX;				_prevY = _spBoard.mouseY;				_curTheta += (_prevX - locX);				_curPhi += (_prevY - locY);								renderView( _curTheta, _curPhi );								e.updateAfterEvent( );			}		}		private function side0Clicked(e : MouseEvent) : void {				_curTheta = 0;				_curPhi = 0;				renderView( _curTheta, _curPhi );						Logger.$.info( this, "side0" );		}		private function side1Clicked(e : MouseEvent) : void {				_curTheta = -180;				_curPhi = 0;				renderView( _curTheta, _curPhi );						Logger.$.info( this, "side1" );		}				private function renderView(t : Number,p : Number) : void {				var i : int;			var distArray : Array = [];			var dispArray : Array = [];			var vertsNewArray : Array = [];			var midPoint : Array = [];			var curv0 : Array = [];			var curv1 : Array = [];			var curv2 : Array = [];			var curv3 : Array = [];			var curImg : BitmapData;			var dist : Number;			var curFace : uint;						t = t * Math.PI / 180;			p = (p+90) * Math.PI / 180;				_side0.graphics.clear( );			_side1.graphics.clear( );							for(i = 0; i < _numVertices ;i++) {						vertsNewArray[i] = pointNewView( _vertsArray[i], t, p ); 			}					for(i = 0; i < _numFaces ;i++) {						midPoint[0] = (vertsNewArray[_facesArray[i][0]][0] + vertsNewArray[_facesArray[i][1]][0] + vertsNewArray[_facesArray[i][2]][0] + vertsNewArray[_facesArray[i][3]][0]) / 4;				midPoint[1] = (vertsNewArray[_facesArray[i][0]][1] + vertsNewArray[_facesArray[i][1]][1] + vertsNewArray[_facesArray[i][2]][1] + vertsNewArray[_facesArray[i][3]][1]) / 4;				midPoint[2] = (vertsNewArray[_facesArray[i][0]][2] + vertsNewArray[_facesArray[i][1]][2] + vertsNewArray[_facesArray[i][2]][2] + vertsNewArray[_facesArray[i][3]][2]) / 4;						dist = Math.sqrt( Math.pow( _fLen - midPoint[0], 2 ) + Math.pow( midPoint[1], 2 ) + Math.pow( midPoint[2], 2 ) );						distArray[i] = [ dist,i ];			}				distArray.sort( byDist );				for(i = 0; i < _numVertices ;i++) {							dispArray[i] = [ _fLen / (_fLen - vertsNewArray[i][0]) * vertsNewArray[i][1],-_fLen / (_fLen - vertsNewArray[i][0]) * vertsNewArray[i][2] ];			}				for(i = 0; i < _numFaces ;i++) {						curFace = distArray[i][1];						curv0 = [ dispArray[_facesArray[curFace][0]][0],dispArray[_facesArray[curFace][0]][1] ];				curv1 = [ dispArray[_facesArray[curFace][1]][0],dispArray[_facesArray[curFace][1]][1] ];				curv2 = [ dispArray[_facesArray[curFace][2]][0],dispArray[_facesArray[curFace][2]][1] ];				curv3 = [ dispArray[_facesArray[curFace][3]][0],dispArray[_facesArray[curFace][3]][1] ];						curImg = _facesArray[curFace][4];						_spCube.setChildIndex( this["_side" + String( curFace )], _spCube.numChildren - 1 );						_bdTransform.mapBitmapData( curImg, new Point( curv0[0], curv0[1] ), new Point( curv1[0], curv1[1] ), new Point( curv2[0], curv2[1] ), new Point( curv3[0], curv3[1] ), this["_side" + String( curFace )] );			}		}		private function byDist(v : Array,w : Array) : Number {				if (v[0] > w[0]) {						return -1;			} else if (v[0] < w[0]) {						return 1;			} else {						return 0;			}		}		private function pointNewView(v : Array,theta : Number,phi : Number) : Array {				var newCoords : Array = [];						newCoords[0] = v[0] * Math.cos( theta ) * Math.sin( phi ) + v[1] * Math.sin( theta ) * Math.sin( phi ) + v[2] * Math.cos( phi );			newCoords[1] = -v[0] * Math.sin( theta ) + v[1] * Math.cos( theta );			newCoords[2] = -v[0] * Math.cos( theta ) * Math.cos( phi ) - v[1] * Math.sin( theta ) * Math.cos( phi ) + v[2] * Math.sin( phi );			/*						newCoords[0] = -v[0] * Math.cos( theta ) * Math.cos( phi ) - v[1] * Math.sin( theta ) * Math.cos( phi ) + v[2] * Math.sin( phi );			newCoords[1] = v[0] * Math.cos( theta ) * Math.sin( phi ) + v[1] * Math.sin( theta ) * Math.sin( phi ) + v[2] * Math.cos( phi );			newCoords[2] = -v[0] * Math.sin( theta ) + v[1] * Math.cos( theta );			*/			return newCoords;		}		public function setBackLook(b : Number,r : Number,t : Number) : void {		  			drawBack( b, r, t, _boardSize );		}	}}