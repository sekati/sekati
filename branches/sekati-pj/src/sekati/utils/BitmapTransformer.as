/** * BitmapTransformer * @version 1.0.0 * @author pj ahlberg * Copyright (C) 2009  pj ahlberg. All Rights Reserved. *  *  */package sekati.utils{	import flash.display.*;	import flash.geom.Matrix;	import flash.geom.Point;	public class BitmapTransformer {		private var _dataWidth : Number;		private var _dataHeight : Number;		private var _vertsArray : Array;		private var _newVertsArray : Array;		private var _hDiv : int;		private var _vDiv : int;		public var _smooth : Boolean;		public function BitmapTransformer(w : Number,h : Number, hdiv : int = 5, vdiv : int = 5, smooth:Boolean = false) {						_dataWidth = w;			_dataHeight = h;			_hDiv = hdiv;			_vDiv = vdiv;			_vertsArray = new Array();			_newVertsArray = new Array();			_smooth = smooth;						setVertices( );		}				private function setVertices() : void {									var hStep : Number = _dataWidth / _hDiv;			var vStep : Number = _dataHeight / _vDiv;						for(var j:int = 0; j <= _vDiv ;j++) {								_vertsArray[j] = [];								for(var i : int = 0; i <= _hDiv ;i++) {					_vertsArray[j][i] = new Point( i * hStep, j * vStep );				}			}		}		private function calcNewVerts(a : Point,b : Point,c : Point,d : Point) : void {						var verVecLeft : Array = [ d.x - a.x,d.y - a.y ];			var verVecRight : Array = [ c.x - b.x,c.y - b.y ];			var curVert : Point;			var curYCoeff : Number;			var curXCoeff : Number;			var curPointLeft : Point = new Point( );			var curPointRight : Point = new Point( );			var newVert : Point = new Point( );						for(var j : int = 0; j <= _vDiv ;j++) {								_newVertsArray[j] = [];								for(var i : int = 0; i <= _hDiv ;i++) {										_newVertsArray[j][i] = new Point( );					curVert = _vertsArray[j][i];					curYCoeff = curVert.y / _dataHeight;					curXCoeff = curVert.x / _dataWidth;					curPointLeft.x = a.x + curYCoeff * verVecLeft[0];					curPointLeft.y = a.y + curYCoeff * verVecLeft[1];					curPointRight.x = b.x + curYCoeff * verVecRight[0];					curPointRight.y = b.y + curYCoeff * verVecRight[1];					newVert.x = curPointLeft.x + (curPointRight.x - curPointLeft.x) * curXCoeff;					newVert.y = curPointLeft.y + (curPointRight.y - curPointLeft.y) * curXCoeff;					_newVertsArray[j][i].x = newVert.x;					_newVertsArray[j][i].y = newVert.y;				}			}		}		public function mapBitmapData(bd : BitmapData,topl : Point,topr : Point,botr : Point,botl : Point, cont : Sprite) : void {			var curVertOld0 : Point = new Point( );			var curVertNew0 : Point = new Point( );			var curVertOld1 : Point = new Point( );			var curVertNew1 : Point = new Point( );			var curVertOld2 : Point = new Point( );			var curVertNew2 : Point = new Point( );			var finMat : Matrix = new Matrix( );			var linMat : Matrix = new Matrix( );						calcNewVerts( topl, topr, botr, botl );						for(var j : int = 0; j < _vDiv ;j++) {				for(var i : int = 0; i < _hDiv ;i++) {										curVertOld0.x = _vertsArray[j][i].x;					curVertOld0.y = _vertsArray[j][i].y;					curVertOld1.x = _vertsArray[j + 1][i].x;					curVertOld1.y = _vertsArray[j + 1][i].y;					curVertOld2.x = _vertsArray[j][i + 1].x;					curVertOld2.y = _vertsArray[j][i + 1].y;					curVertNew0.x = _newVertsArray[j][i].x;					curVertNew0.y = _newVertsArray[j][i].y;					curVertNew1.x = _newVertsArray[j + 1][i].x;					curVertNew1.y = _newVertsArray[j + 1][i].y;					curVertNew2.x = _newVertsArray[j][i + 1].x;					curVertNew2.y = _newVertsArray[j][i + 1].y;									finMat.tx = curVertOld0.x;					finMat.ty = curVertOld0.y;					finMat.a = 0;					finMat.b = (curVertOld1.y - curVertOld0.y) / _dataWidth;					finMat.c = (curVertOld2.x - curVertOld0.x) / _dataHeight;					finMat.d = 0;					linMat.a = (curVertNew1.x - curVertNew0.x) / _dataWidth;					linMat.b = (curVertNew1.y - curVertNew0.y) / _dataWidth;					linMat.c = (curVertNew2.x - curVertNew0.x) / _dataHeight;					linMat.d = (curVertNew2.y - curVertNew0.y) / _dataHeight;					linMat.tx = curVertNew0.x;					linMat.ty = curVertNew0.y;					finMat.invert( );					finMat.concat( linMat );									cont.graphics.beginBitmapFill( bd, finMat, false, _smooth );					cont.graphics.moveTo( curVertNew0.x, curVertNew0.y );					cont.graphics.lineTo( curVertNew1.x, curVertNew1.y );					cont.graphics.lineTo( curVertNew2.x, curVertNew2.y );					cont.graphics.lineTo( curVertNew0.x, curVertNew0.y );					cont.graphics.endFill( );										curVertOld0.x = _vertsArray[j + 1][i + 1].x;					curVertOld0.y = _vertsArray[j + 1][i + 1].y;					curVertOld1.x = _vertsArray[j][i + 1].x;					curVertOld1.y = _vertsArray[j][i + 1].y;					curVertOld2.x = _vertsArray[j + 1][i].x;					curVertOld2.y = _vertsArray[j + 1][i].y;					curVertNew0.x = _newVertsArray[j + 1][i + 1].x;					curVertNew0.y = _newVertsArray[j + 1][i + 1].y;					curVertNew1.x = _newVertsArray[j][i + 1].x;					curVertNew1.y = _newVertsArray[j][i + 1].y;					curVertNew2.x = _newVertsArray[j + 1][i].x;					curVertNew2.y = _newVertsArray[j + 1][i].y;										finMat.tx = curVertOld0.x;					finMat.ty = curVertOld0.y;					finMat.a = 0;					finMat.b = (curVertOld1.y - curVertOld0.y) / _dataWidth;					finMat.c = (curVertOld2.x - curVertOld0.x) / _dataHeight;					finMat.d = 0;					linMat.a = (curVertNew1.x - curVertNew0.x) / _dataWidth;					linMat.b = (curVertNew1.y - curVertNew0.y) / _dataWidth;					linMat.c = (curVertNew2.x - curVertNew0.x) / _dataHeight;					linMat.d = (curVertNew2.y - curVertNew0.y) / _dataHeight;					linMat.tx = curVertNew0.x;					linMat.ty = curVertNew0.y;					finMat.invert( );					finMat.concat( linMat );									cont.graphics.beginBitmapFill( bd, finMat, false, _smooth );					cont.graphics.moveTo( curVertNew0.x, curVertNew0.y );					cont.graphics.lineTo( curVertNew1.x, curVertNew1.y );					cont.graphics.lineTo( curVertNew2.x, curVertNew2.y );					cont.graphics.lineTo( curVertNew0.x, curVertNew0.y );										cont.graphics.endFill( );				}			}		}	}}