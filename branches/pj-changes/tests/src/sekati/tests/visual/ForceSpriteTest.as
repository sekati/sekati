/** * sekati.tests.visual.ForceSpriteTest * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.tests.visual {	import sekati.display.Canvas;	import sekati.display.ForceSprite;	import sekati.draw.Rect;	import sekati.log.Logger;	import sekati.math.MathBase;	import sekati.math.Random;	import sekati.tests.visual.AbstractTestApplication;	import flash.display.Sprite;	import flash.events.KeyboardEvent;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.ui.Keyboard;		/**	 * ForceSpriteTest	 */	public class ForceSpriteTest extends AbstractTestApplication {		public static const ALPHA : Number = 0.75;		public static const COLOR : uint = 0x00ffff;		public static const HILITE : uint = 0xff00ff;		public static const SIZE : uint = 25;		public static const AMOUNT : int = 50;		public static const ACCELERATION : Number = 10;		public static const FRICTION : Number = 0.9;		public static const GRAVITY : int = 20;		public var a : Array;		public function ForceSpriteTest() {			super( );		}		override protected function initEntryPoint() : void {			//super.initEntryPoint( );			cacheAsBitmap = true;			a = new Array( );			var bg : Rect = new Rect( Canvas.stage.stageWidth, Canvas.stage.stageHeight, 0, 0, 0, 0 );			var tf : TextField = new TextField( );			tf.autoSize = TextFieldAutoSize.LEFT;			tf.textColor = 0xffffff;			tf.text = "Test forces with arrows keys or grab/throw objects.".toUpperCase( );			addChildren( bg, tf );						for (var i : int = 0; i < AMOUNT ; i++) {				var size : Number = MathBase.random( SIZE / 3, SIZE * 3 );				var mass : Number = (size / (SIZE * 3));				//mass = MathBase.clamp( mass, 0, 0.9 );				Logger.$.trace( this, "mass: " + mass );								//var test : ForceSprite = new ForceSprite( rnd( 0, 25 ), rnd( 0, 25 ), mass, FRICTION, GRAVITY );				//var test : ForceSprite = new ForceSprite( rnd( ), rnd( ) );				var test : ForceSprite = new ForceSprite( 0, 0, mass, 0.6 );				if(Random.boolean( ) == true) {					drawRect( test, size );				} else {					drawCircle( test, size );				}				a.push( test );			}						// add the force sprites			addChildren.apply( this, a );			initKeys( );		}		/**		 * Key Listeners		 */		private function initKeys() : void {			Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler );			Canvas.stage.addEventListener( KeyboardEvent.KEY_UP, keyUpHandler );		}		private function keyUpHandler(e : KeyboardEvent) : void {			for (var i : int = 0; i < a.length ; i++) {				a[i].gravityY = 10;				a[i].ax = 0;				a[i].ay = 0;			}		}		private function keyDownHandler(e : KeyboardEvent) : void {			var ax : Number = 0;			var ay : Number = 0;			var gravity : Number = GRAVITY;			switch (e.keyCode) { 						//User pressed the left arrow --> x acceleration negative				case Keyboard.LEFT :					ax = -ACCELERATION;					break; 			//User pressed the right arrow --> x acceleration positive				case Keyboard.RIGHT :					ax = ACCELERATION;					break;			//User pressed the up arrow --> y acceleration negative. Apply no gravity when up key down.				case Keyboard.UP :					ay = -ACCELERATION; //* 0.25;					gravity = 0;					break;			//User pressed the down arrow --> y acceleration positivve				case Keyboard.DOWN :					ay = ACCELERATION;					break;			}						// pass the key'd accelerations to the force sprite ..			for (var i : int = 0; i < a.length ; i++) {				a[i].ax = ax;				a[i].ay = ay;				a[i].gravityY = gravity;				}		}		/**		 * Ranged random.		 */		protected function rnd(start : Number = 0, finish : Number = 50) : Number {			return MathBase.random( start, finish );		}		/**		 * Draw a rectangle.		 */		public function drawRect(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawRect( 0, 0, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE );			registerShape( s );					}		/**		 * Draw a circle		 */		public function drawCircle(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawCircle( size, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE * 2 );			registerShape( s );		}		/**		 * Place a registration mark.		 */		public function registerShape(s : Sprite) : void {			s.graphics.beginFill( HILITE, 1 );			s.graphics.drawRect( 0, 0, 5, 5 );			s.graphics.endFill( );		}			}}