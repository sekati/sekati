/** * sekati.tests.visual.ForceSpriteCollisionTest * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.tests.visual {	import sekati.collisions.Collision;	import sekati.collisions.CollisionAngle;	import sekati.collisions.CollisionDetector;	import sekati.display.Canvas;	import sekati.display.ForceSprite;	import sekati.draw.Rect;	import sekati.events.CollisionEvent;	import sekati.math.MathBase;	import sekati.math.Random;	import sekati.tests.visual.AbstractTestApplication;	import sekati.utils.AlignUtil;		import flash.display.Sprite;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;			/**	 * ForceSpriteCollisionTest	 */	public class ForceSpriteCollisionTest extends AbstractTestApplication {		public var detector : CollisionDetector;		public static const ALPHA : Number = 0.75;		public static const COLOR : uint = 0x00ffff;		public static const HILITE : uint = 0xff00ff;		public static const SIZE : uint = 50;		public static const AMOUNT : int = 5;		public var a : Array;		public function ForceSpriteCollisionTest() {			super( );		}		override protected function initEntryPoint() : void {			//super.initEntryPoint( );			cacheAsBitmap = true;			a = new Array( );			var bg : Rect = new Rect( Canvas.stage.stageWidth, Canvas.stage.stageHeight, 0, 0, 0, 0 );			a.push( bg );						var block : Rect = new Rect( 500, 1, 0, 0, 0, 0xff0000 );			AlignUtil.stageAlignCenter( block );			a.push( block );						detector = new CollisionDetector( block );						for (var i : int = 0; i < AMOUNT ; i++) {				var test : ForceSprite = new ForceSprite( rnd( ), rnd( ) );				var size : Number = MathBase.random( SIZE / 3, SIZE * 3 );				if(Random.boolean( ) == true) {					drawRect( test, size );				} else {					drawCircle( test, size );				}				a.push( test );				detector.addItem( test );			}						// add the force sprites			addChildren.apply( this, a );						// start detection			detector.addEventListener( CollisionEvent.COLLISION, collisionHandler );			detector.returnAngleType = CollisionAngle.RADIAN;			detector.startMonitor( );			//initKeys( );		}		/**		 * Key Listeners		 */		protected function initKeys() : void {			Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler );			Canvas.stage.addEventListener( KeyboardEvent.KEY_UP, keyUpHandler );		}		private function keyUpHandler(e : KeyboardEvent) : void {			for (var i : int = 0; i < a.length ; i++) {				a[i].gravity = 0.5;				a[i].ax = 0;				a[i].ay = 0;			}		}		private function keyDownHandler(e : KeyboardEvent) : void {			var ax : Number = 0;			var ay : Number = 0;			var gravity : Number = 0;			switch (e.keyCode) { 						//User pressed the left arrow --> x acceleration negative				case Keyboard.LEFT :					ax = -0.5;					break; 			//User pressed the right arrow --> x acceleration positivve				case Keyboard.RIGHT :					ax = 0.5;					break;			//User pressed the up arrow --> y acceleration negative. Apply no gravity when up key down.				case Keyboard.UP :					gravity = 0;					ay = -0.5;					break;			//User pressed the down arrow --> y acceleration positivve				case Keyboard.DOWN :					ay = 0.5;					break;			}						for (var i : int = 0; i < a.length ; i++) {				a[i].ax = ax;				a[i].ay = ay;				a[i].gravity = gravity;				}		}		/**		 * Handle collision events!		 */		private function collisionHandler(ev : CollisionEvent) : void {			//Logger.$.info( this, "Collision: " + e );			for (var i : int = 0; i < ev.collisions.length ; i++) {				var collision : Collision = ev.collisions[i];				var obj : ForceSprite = collision.object2 as ForceSprite;				try {					obj.collide( );				} catch (e : Error) {				}			}		}		/**		 * Ranged random.		 */		private function rnd(start : Number = 0, finish : Number = 50) : Number {			return MathBase.random( start, finish );		}		/**		 * Draw a rectangle.		 */		public function drawRect(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawRect( 0, 0, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE );			registerShape( s );					}		/**		 * Draw a circle		 */		public function drawCircle(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawCircle( size, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE * 2 );			registerShape( s );		}		/**		 * Place a registration mark.		 */		public function registerShape(s : Sprite) : void {			s.graphics.beginFill( HILITE, 1 );			s.graphics.drawRect( 0, 0, 5, 5 );			s.graphics.endFill( );		}			}}