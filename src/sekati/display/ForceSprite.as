/** * sekati.display.ForceSprite * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.display {	import sekati.display.InteractiveSprite;	import sekati.events.FramePulse;		import flash.events.Event;	import flash.geom.Rectangle;			/**	 * ForceSprite provides a <code>Sprite</code> which may have physics forces applied to it.	 */	public class ForceSprite extends InteractiveSprite {		protected var _boundRect : Rectangle;		protected var _speedX : Number;		protected var _speedY : Number;		protected var _ax : Number;		protected var _ay : Number;		protected var _friction : Number;		protected var _gravity : Number;		protected var _hasForce : Boolean;		/**		 * ForceSprite Constructor		 * @param speedX 	starting speed on x-axis.		 * @param speedY 	starting speed of y-axis.		 * @param bounds 	the bounds of movement for the object.		 * @param friction 	applied to the object.		 * @param gravity 	applied to the object.		 * @param hasForce 	whether the force is currently being applied.		 */		public function ForceSprite(speedX : Number = 0, speedY : Number = 0, friction : Number = 0.95, gravity : Number = 10, bounds : Rectangle = null, hasForce : Boolean = true) {			super( );			if(bounds) {				this.bounds = bounds;				// constrain within bounds if the default position has overflow				if (x + width >= boundRight || x <= boundLeft) x = boundLeft;				if (y + height >= boundBottom || y <= boundTop) y = boundTop;			}			_speedX = speedX;			_speedY = speedY;			_ax = 0;			_ay = 0;			_friction = friction;			_gravity = gravity;			this.hasForce = hasForce;			interactiveMode = false;		}		/**		 * Handle a collision		 */		public function collide(radian : Number) : void {			//var sin : Number = Math.sin( radian );			//var cos : Number = Math.cos( radian );			//_speedX *= radian;			//_speedY *= radian;			_speedY *= -1;			_speedX *= -1;		}		/**		 * Handle force logic.		 */		protected function frameHandler(e : Event) : void {				//trace( x + "," + y );			// each frame: add the necessary "forces" that moves the object.			_speedY += _gravity;			_speedY += _ay;			_speedX += _ax;			// each frame: decrease the speed, so the object won't bounce forever.			_speedY *= _friction;			_speedX *= _friction;						// place object			y += _speedY;			x += _speedX;								//Let's check when the object hits the bottom.			if (y > boundBottom ) {				//When we hit the bottom, reposition the object to be exactly on the				//bottom edge. Change the sign of the speedY so we go to the other direction.				y = boundBottom;				_speedY *= -1;			} else if (y < boundTop) {				//Check if the object hits the top				y = 0;				_speedY *= -1;			}			//Check the right edge			if (x > boundRight) {				x = boundRight;				_speedX *= -1;			} else if (x < boundLeft) {				//Check the left edge				x = 0;				_speedX *= -1;			}			//if (_speedX < 0.1 && _speedX > -0.1) _speedX = 0;			//if (_speedY < 0.1 && _speedY > -0.1) _speedY = 0;						}									/**		 * Rectangle value relative to the coordinates of the Sprite's parent that specify a constraint area for the DraggableSprite.		 * <p>If <code>bounds</code> has not been set the <code>Canvas.stage</code> bounds are automatically implemented instead.</p>		 */		public function get bounds() : Rectangle {			return (_boundRect != null) ? _boundRect : new Rectangle( 0, 0, Canvas.stage.stageWidth, Canvas.stage.stageHeight );		}		/**		 * @private		 */		public function set bounds(r : Rectangle) : void {			_boundRect = r;		}		/**		 * Left bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundLeft() : Number {			return bounds.x;		}		/**		 * Right bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundRight() : Number {			return bounds.width - width;		}		/**		 * Top bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundTop() : Number {			return bounds.y;		}		/**		 * Bottom bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundBottom() : Number {			return bounds.height - height;		}		/**		 * <code>Boolean</code> value which determines whether the force (<code>frameHandler</code>) is currently being applied. 		 */		public function get hasForce() : Boolean {			return _hasForce;		}		/*** @private */		public function set hasForce(b : Boolean) : void {			if(b && !_hasForce) {				FramePulse.$.addFrameListener( frameHandler );			} else if(!b && _hasForce) {				FramePulse.$.removeFrameListener( frameHandler );			}			_hasForce = hasForce;		}		/**		 * X-axis acceleration.		 */		public function get ax() : Number {			return _ax;		}		/*** @private */		public function set ax(n : Number) : void {			_ax = n;		}		/**		 * Y-axis acceleration.		 */		public function get ay() : Number {			return _ay;		}		/*** @private */		public function set ay(n : Number) : void {			_ay = n;		}		/**		 * Frictional force being applied.		 */		public function get friction() : Number {			return _friction;		}		/*** @private */		public function set friction(n : Number) : void {			_friction = n;		}		/**		 * Gravitational force being applied.		 */		public function get gravity() : Number {			return _gravity;		}		/*** @private */		public function set gravity(n : Number) : void {			_gravity = n;		}	}}