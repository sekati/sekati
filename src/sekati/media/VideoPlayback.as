/** * @version 1.0 * @author David Dahlstroem | hello@daviddahlstroem.com *  * Copyright (C) 2009 David Dahlstroem. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.media {	import sekati.core.ICoreInterface;	import sekati.events.LoaderEvent;	import sekati.load.VideoLoader;	import sekati.reflect.Stringifier;		import flash.media.SoundTransform;	import flash.media.Video;		/**	 * VideoPlayback provides an API coupled with VideoLoader class and is used for playing back video.	 *	 * @see sekati.load.VideoLoader	 */	 	/*	 * TODO Extend functionality of VideoPlayback class	 * TODO There's an issue with F4V files not displaying and FLV files displaying after a delay.	 */		public class VideoPlayback extends Video implements MediaPlayback, ICoreInterface	{				private var _loader:VideoLoader;				private var _playing:Boolean;				private var _autoSize:Boolean;				private var _soundTransform:SoundTransform;				/**		 * VideoPlayback constructor.		 * 		 * @param loader VideoLoader providing the video data to be played.		 * @param width Video width.		 * @param height Video height.		 */				public function VideoPlayback(loader:VideoLoader, width:int = 320, height:int = 240)		{			super(width, height);						_loader = loader;						attachNetStream(_loader.netStream);						_playing = false;						_soundTransform = new SoundTransform();		}				/**		 * Returns the VideoLoader instance coupled with the VideoPlayback instance.		 */				public function get videoLoader():VideoLoader		{			return _loader;		}				/**		 * Defines whether the video is to be resized to the values provided by the loaded metadata.		 * If meta data has not yet been loaded, the video will be resized when meta data loading is complete.		 */				public function get autoSize():Boolean		{			return _autoSize;		}				public function set autoSize(value:Boolean):void		{			_autoSize = value;						if(autoSize)			{				if(videoLoader.hasMetaData)				{					width = videoLoader.metaData.width;										height = videoLoader.metaData.height;				}				else				{					videoLoader.addEventListener(LoaderEvent.META_DATA, onMetaDataRecieve);				}			}		}				/**		 * Returns the buffer length of the video playback.		 */				public function get bufferLength():Number		{			return videoLoader.netStream.bufferLength;		}				/**		 * Defines the buffer time of the video playback.		 */				public function get bufferTime():Number		{			return videoLoader.netStream.bufferTime;		}				public function set bufferTime(value:Number):void		{			videoLoader.netStream.bufferTime = value;		}				/**		 * Indicates the duration of the vide playback. If metadata isn't yet loaded a qualified guess of the duration will be returned.		 */				public function get duration():Number		{			return videoLoader.metaData.duration || (videoLoader.bytesTotal / (videoLoader.bytesLoaded / bufferLength));		}				/**		 * Indicates the position of the playhead, in seconds.		 */				public function get time():Number		{			return videoLoader.netStream.time;		}				/**		 * Defines the audio volume of the video playback.		 */				public function get volume():Number		{			return _soundTransform.volume;		}				public function set volume(value:Number):void		{			_soundTransform.volume = value;						videoLoader.netStream.soundTransform = _soundTransform;		}				/**		 * Defines the audio pan of the video playback.		 */				public function get pan():Number		{			return _soundTransform.pan;		}				public function set pan(value:Number):void		{			_soundTransform.pan = value;						videoLoader.netStream.soundTransform = _soundTransform;		}				/**		 * Starts video playback.		 */				public function play():void		{			videoLoader.netStream.resume();		}				/**		 * Starts video playback at specified position.		 */				public function playAt(position:Number):void		{			videoLoader.netStream.seek(position);			videoLoader.netStream.play();		}				/**		 * Pauses video playback.		 */				public function pause():void		{			videoLoader.netStream.pause();		}				/**		 * Stops video playback.		 */				public function stop():void		{			pause();			seek(0);		}				/**		 * Moves the playhead to specified position.		 */				public function seek(position:Number):void		{			videoLoader.netStream.seek(position);		}				/**		 * destroys of the VideoPlayback instance.		 */				public function destroy():void		{			_loader = null;		}				/**		 * @inheritDoc		 */				override public function toString():String		{			return Stringifier.stringify(this);		}				private function onMetaDataRecieve(e:LoaderEvent):void		{			videoLoader.removeEventListener(LoaderEvent.META_DATA, onMetaDataRecieve);						if(autoSize)			{				width = videoLoader.metaData.width;										height = videoLoader.metaData.height;			}			}	}}