/** * sekati.media.FLV * @version 1.3.2 * @author jason m horwitz & steve baughman | sekati.com * Copyright (C) 2008-2009 jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.media {	import sekati.log.Logger;		import sekati.events.FramePulse;	import sekati.events.MediaEvent;	import sekati.validators.FileTypeValidator;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;			/**	 * FLV provides a common media control object for playing <i>progressive</i> video content. 	 * Acceptable file types are defined in <code>FileTypeValidator.IS_VIDEO</code>.	 * 	 * @see sekati.events.MediaEvent	 * @see sekati.ui.FLVPlayer	 */	public class FLV2 extends EventDispatcher {		protected var _ns : NetStream;		protected var _nc : NetConnection;		protected var _client : Object;		protected var _video : Video;		protected var _url : String;		protected var _paused : Boolean;		protected var _started : Boolean;		protected var _duration : Number;		protected var _metadata : Object;		protected var _lastSeekableTime : Number;		protected var _bufferTime : Number;		protected var _bufferPause : Boolean;				/**		 * FLV Constructor		 */		public function FLV2(width : int = 320, height : int = 240, smoothing : Boolean = true) {			super( );			_paused = false;			_started = false;			_duration = 1000000000; // fix for buffer bar flakiness			_video = new Video( width, height );			_video.smoothing = smoothing;		}		/**		 * Load the video and begin playback.		 * @param url 		of the video to be loaded.		 * @param buffer 	seconds to buffer.		 * @throws 			ArgumentError if <code>url</code> is not video type.		 */		public function load(url : String, buffer : uint = 4) : void {			if(!FileTypeValidator.isVideo( url )) {				throw new ArgumentError( "FLV.load() Argument Error: '" + url + "' is not a valid video file type according to FileTypeValidator.IS_VIDEO." );			}			_url = url;			_nc = new NetConnection( );			_nc.connect( null );			_client = new Object( );			_ns = new NetStream( _nc );			_video.attachNetStream( _ns );						/* The standard NS.bufferTime will fire cuePoints out of order			 * so we will utilize a smart-buffer we build ourselves.			 * @see http://www.restlessthinker.com/blog/?p=44			 * // _ns.bufferTime = buffer; 			 */			_bufferTime = buffer;		 						_ns.client = this;			_ns.addEventListener( NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true );			_client['onMetaData'] = metaDataHandler;			_client['onCuePoint'] = cuePointHandler;			_ns.client = _client;						//start to load movie, pause and put on first frame to see something			play( );			stop( );			FramePulse.$.addFrameListener( progressHandler );		}		// BASIC CONTROLLERS				/**		 * Start playback.		 */		public function play() : void {			_started = true;			_ns.play( _url );		}		/**		 * Stop playback.		 */		public function stop() : void {			_ns.pause( );			_started = false;			_paused = false;		}		/**		 * Pause playback.		 */		public function pause() : void {			if (!_paused && _started) {				_paused = true;				_ns.togglePause( );			}		}		/**		 * Resume playback.		 */		public function resume() : void {			if (_paused && _started) {				_paused = false;				_ns.togglePause( );			}		}		/**		 * Pause/Resume playback toggle.		 */		public function togglePause() : void {			_paused ? resume( ) : pause( );		}		/**		 * Seek to a playback time.		 * @param time 		in playback to seek to.		 */		public function seek(time : Number) : void {			_ns.seek( resolveTime( time ) );		}		/**		 * Seek to a playback percent (0 - 1).		 * @param percent 	of playback to seek to.		 */		public function seekToPercent(percent : Number) : void {			seek( _duration * percent );		}		/**		 * Fast-Forward playback.		 * @param seconds 		to step forward.		 */		public function fastForward(seconds : Number = 2) : void {			seek( time + seconds );		}		/**		 * Rewind playback.		 * @param seconds 		to step back.		 */		public function rewind(seconds : Number = 2) : void {			seek( time - seconds );		}		/**		 * Stop playback and cleanup after self.		 */		public function destroy() : void {			stop( );			FramePulse.$.removeFrameListener( progressHandler );			_ns.removeEventListener( NetStatusEvent.NET_STATUS, netStatusHandler );			_video.clear( );			_ns.close( );			_nc.close( );			_video = null;			_ns = null;			_nc = null;			_client = null;		}		/**		 * Formats time so that it fits inside the available seek scope.		 */		protected function resolveTime(time : Number) : Number {			var maxTime : Number = (!isNaN( _lastSeekableTime )) ? _lastSeekableTime : _duration;			return Math.max( Math.min( time, maxTime ), 0 );		}		/**		 * Handle buffer externally to <code>ns.bufferTime</code> so we can achieve proper cuePoint timing.		 */		protected function checkBuffer() : void {			// we're outta buffer ...			if(percentLoaded <= percentPlayed) {				// video has finished loading				if(percentLoaded >= 1) return; 				// pause playback				if(!_bufferPause) {					dispatchEvent( new MediaEvent( MediaEvent.REBUFFER ) );					_bufferPause = true;				}			} else if(percentLoaded >= percentPlayedWithBuffer) {				// resume playback				if(_bufferPause) {					_bufferPause = false;					dispatchEvent( new MediaEvent( MediaEvent.REBUFFER_COMPLETE ) );				}			}		}		// PROGRESS, NETSTREAM & NETCONNECTION EVENT HANDLERS		/**		 * Progress frame loop to keep client progress up to date.			 */		protected function progressHandler(e : Event) : void {			dispatchEvent( new MediaEvent( MediaEvent.PROGRESS, null, percentLoaded, percentPlayed ) );			checkBuffer( );		}		/**		 * NetStatus handler.		 */		protected function netStatusHandler(stats : NetStatusEvent) : void {			//trace( "netstat: " + stats.info['code'] );			switch (stats.info['code']) {				case "NetStream.Buffer.Empty" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_EMPTY, "bufferEmpty" ) );					break;				case "NetStream.Buffer.Full" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FULL, "bufferFull" ) );					break;				case "NetStream.Buffer.Flush" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FLUSH, "bufferFlush" ) );					break;				case "NetStream.Play.Start" :					dispatchEvent( new MediaEvent( MediaEvent.START, "start" ) );					break;				case "NetStream.Play.Stop" :					dispatchEvent( new MediaEvent( MediaEvent.STOP, "stop" ) );					break;				case "NetStream.Play.StreamNotFound" :					dispatchEvent( new MediaEvent( MediaEvent.STREAM_NOT_FOUND, "play_streamNotFound" ) );					break;				case "NetStream.Seek.InvalidTime" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_INVALID_TIME, "seek_InvalidTime" ) );					break;				case "NetStream.Seek.Notify" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_NOTIFY, "seek_notify" ) );					break;				default :					//trace( "Unrecognized NetStatusEvent value: " + stats.info['code'] );					dispatchEvent( new MediaEvent( MediaEvent.UNRECOGNIZED, stats.info['code'] ) );			}					}		/**		 * <code>NetStream</code> cuepoint handler.		 */		protected function cuePointHandler(infoObject : Object) : void { 			dispatchEvent( new MediaEvent( MediaEvent.CUE_POINT, MediaEvent.CUE_POINT, NaN, NaN, null, infoObject ) );			Logger.$.info( this, "cuePointHandler:" );			Logger.$.object( infoObject );		  	/*			for (var propName:String in infoObject) {				if (propName != "parameters") {					trace( propName + " = " + infoObject[propName] );				}		        else {					trace( "parameters =" );					if (infoObject['parameters'] != undefined) {						for (var paramName:String in infoObject['parameters']) {							trace( paramName + ": " + infoObject['parameters'][paramName] );						}					}		            else {						trace( "undefined" );					}				} 			}			 */		}				/**		 * <code>NetStream</code> metadata handler.		 */		protected function metaDataHandler(metadata : Object) : void {			_duration = metadata['duration'];			_lastSeekableTime = metadata['lastkeyframetimestamp'];			_metadata = metadata;			dispatchEvent( new MediaEvent( MediaEvent.METADATA, MediaEvent.METADATA, NaN, NaN, metadata ) );						Logger.$.info( this, "metaDataHandler event @ " + _ns.time + " => duration: " + metadata['duration'] + ", lastkeyframetimestamp: " + metadata['lastkeyframetimestamp'] + " metadata:" );			Logger.$.object( metadata );						/*			//depends on which application was used to encode the FLV file			SORENSON - INITIAL META:			creationdate - Mon Jun 12 16:21:12 2006 			framerate - 29.9699859619141			audiocodecid - 2			audiodatarate - 64			videocodecid - 5			canSeekToEnd - false			videodatarate - 600			height - 358			width - 150			duration - 17.65			 */			//find what metadata is available now:			/*			for (var i in metadata) {				trace( i + " - " + metadata[i] );			}			//trace cuepoints			for (var j:String in metadata.cuePoints) {				trace( "CUEPOINTS: " + j + " - " + metadata.cuePoints[j] );				for (var k:String in metadata.cuePoints[j]) {					trace( "  CUEPOINTS: " + k + " - " + metadata.cuePoints[j][k] );				}			}			*/					}			/**		 * Video paused status.		 */		public function get paused() : Boolean {			return _paused;		}		/**		 * Video buffering status.		 */		public function get buffering() : Boolean {			return _bufferPause;		}		/**		 * Video playing status.		 */		public function get playing() : Boolean {			return _started;		}		/**		 * Video stopped status.		 */		public function get stopped() : Boolean {			return !_started;		}		/**		 * The position of the playhead, in seconds.		 */		public function get time() : Number {			return _ns.time;		}		/**		 * The total playback duration, in seconds.		 */		public function get duration() : Number {				return _duration;		}				/**		 * Amount of play-ahead buffer, in seconds.		 */		public function get bufferLength() : Number {			return _ns.bufferLength;		}		/**		 * Return the percent played (0 - 1). 		 */		public function get percentPlayed() : Number {			return (time / _duration);		}			/**		 * Returns the percent of the movie that <i>should be</i> currently buffered.		 * @see #checkBuffer()		 */		public function get percentPlayedWithBuffer() : Number {			return ((time + _bufferTime) / _duration);		}		/**		 * Return the percent loaded (0 - 1).		 */		public function get percentLoaded() : Number {			return ( _ns.bytesLoaded / _ns.bytesTotal );		}					// AUDIO & VIDEO GETTER		/**		 * The <code>Video</code> instance to be added to the <code>DisplayList</code>.		 */		public function get video() : Video {			return _video;			}			/**		 * The <code>Netstream</code> instance should clients wish to listen to <code>NetStream</code> 		 * directly rather than the more pragmatic but less granular <code>MediaEvent</code>.		 */		public function get ns() : NetStream {			return _ns;			}									/**		 * The <code>Video</code> volume (0 - 1).		 */		public function get volume() : Number {			return _ns.soundTransform.volume;		}		/*** @private */		public function set volume(volume : Number) : void {			var st : SoundTransform = _ns.soundTransform;			st.volume = volume;			_ns.soundTransform = st;		}		/***		 * The <code>Video</code> sound panning (-1 - 1).		 */		public function get pan() : Number {			return _ns.soundTransform.pan;		}		/*** @private */		public function set pan(pan : Number) : void {			var st : SoundTransform = _ns.soundTransform;			st.pan = pan;			_ns.soundTransform = st;			}	}}