/** * @version 1.0 * @author David Dahlstroem | hello@daviddahlstroem.com * Copyright (C) 2008 David Dahlstroem. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.load{	import sekati.core.Cancelable;	import sekati.events.LoaderEvent;	import sekati.events.WeakEventDispatcher;	import sekati.profiler.BandwidthProfiler;	import sekati.reflect.Stringifier;		import flash.errors.IOError;	import flash.events.Event;	import flash.net.URLRequest;	import flash.utils.getTimer;		/**	 * AbstractLoader class is the base class of all loader classes.	 */	public class AbstractLoader extends WeakEventDispatcher implements Loadable 	{				/**		 * Defines the priority of the loader.		 * Loaders with a low priority value will be loaded before loaders with a higher priority value		 * in a loader queue.		 * 		 * @see sekati.load.LoaderQueue		 */				public var priority:uint = 0;				public var name:String;		/** @private */		protected var _sourceURL:String;		/** @private */		protected var _bytesTotalPrefetcher:BytesTotalPrefetcher;		/** @private */		protected var _byteReference:ByteReference;		private var _isLoaded:Boolean = false;		private var _loadStartTime:uint;				private var _loadExecTime:uint;		private var _loadCompleteTime:uint;				private var _bytesLoadedRegisterHolder:uint;				/**		 * AbstractLoader Constructor		 * 		 * @param sourceURL URL pointing at the file to be loaded.		 * @param loaderName Optional name for the loader		 */				public function AbstractLoader(sourceURL:String, loaderName:String = null)		{			super(this);						_sourceURL = sourceURL;						name = loaderName;						_bytesLoadedRegisterHolder = 0;		}		/**		 * @inheritDoc		 */		public function load():void		{			_loadExecTime = getTimer();		}		/**		 * Destroys of the loader and clears it of all loaded data and properties. Any on-going loading is cancelled immediately.		 */		public function destroy():void		{			return;		}		/**		 * @inheritDoc		 */		public function clone():Object		{			return new AbstractLoader(_sourceURL);		}				/**		 * Resets the loader and its properties to what they were upon instantiation.		 */				public function reset():void		{			return;		}		/**		 * @inheritDoc		 */		override public function toString():String		{			return Stringifier.stringify(this);		}		/**		 * @inheritDoc		 */		final public function get progress():Number		{			var p:Number = bytesLoaded / bytesTotal;						return (isNaN(p)) ? 0 : p;		}		/**		 * @inheritDoc		 */		final public function get bytesLoaded():uint		{				return (_byteReference.hasValidTarget) ? _byteReference.bytesLoaded : 0;		}		/**		 * @inheritDoc		 */		final public function get bytesTotal():int		{			if(!_byteReference.hasValidTarget) return 0;						if(_byteReference.bytesTotal <= 0)			{					return (bytesTotalPrefetcher && bytesTotalPrefetcher.prefetchComplete) ? bytesTotalPrefetcher.getPrefetchedBytesTotal() : 0;			}						return _byteReference.bytesTotal;		}		/**		 * @inheritDoc		 */		final public function get loaded():Boolean		{			return _isLoaded;		}		/**		 * @inheritDoc		 */		final public function get loading():Boolean		{			return (_byteReference.bytesLoaded > 0 && _byteReference.bytesLoaded < _byteReference.bytesTotal);		}		/**		 * @inheritDoc		 */		final public function get loadTime():uint		{			return _loadCompleteTime - _loadStartTime;		}		/**		 * @inheritDoc		 */		public function get data():*		{			return null;		}		/**		 * @inheritDoc		 */		final public function getURL():String		{			return _sourceURL;		}				/**		 * @inheritDoc		 */		final public function get latency():uint		{			return _loadExecTime - _loadStartTime;		}		/**		 * @inheritDoc		 */		final public function get cancelable():Boolean		{			return (this is Cancelable);		}		/**		 * @inheritDoc		 */		final public function get bytesTotalPrefetcher():BytesTotalPrefetcher		{			return _bytesTotalPrefetcher;		}		/**		 * @inheritDoc		 */		final public function prefetchBytesTotal():void		{			if(_bytesTotalPrefetcher)			{				_bytesTotalPrefetcher.destroy();				_bytesTotalPrefetcher = null;			}						_bytesTotalPrefetcher = new BytesTotalPrefetcher(new URLRequest(_sourceURL));						_bytesTotalPrefetcher.addEventListener(LoaderEvent.BYTESTOTAL_PREFETCHED, bytesTotalPrefetchComplete);		}		/** @private */		final protected function dispatchLoadStartEvent(e:Event = null):void		{			_isLoaded = false;						_loadStartTime = getTimer();						BandwidthProfiler.getInstance().registerLoadOperation();							BandwidthProfiler.getInstance().registerLoadOperationCurrent();						if(hasEventListener(LoaderEvent.START)) dispatchEvent(new LoaderEvent(LoaderEvent.START));		}		/** @private */		final protected function dispatchLoadProgressEvent(e:Event = null):void		{				_isLoaded = false;						BandwidthProfiler.getInstance().registerBytesLoaded(bytesLoaded - _bytesLoadedRegisterHolder);							_bytesLoadedRegisterHolder = bytesLoaded;						//No need for creating hundreds of new LoaderEvent instances if nobody wants em.			if(hasEventListener(LoaderEvent.PROGRESS)) dispatchEvent(new LoaderEvent(LoaderEvent.PROGRESS));		}		/** @private */		final protected function dispatchLoadCompleteEvent(e:Event = null):void		{			_isLoaded = true;						_loadCompleteTime = getTimer(); 						BandwidthProfiler.getInstance().registerBytesLoaded(bytesLoaded - _bytesLoadedRegisterHolder);							BandwidthProfiler.getInstance().registerLoadOperationCompleted();							_bytesLoadedRegisterHolder = 0;						if(hasEventListener(LoaderEvent.COMPLETE)) dispatchEvent(new LoaderEvent(LoaderEvent.COMPLETE));		}		/** @private */		final protected function dispatchIOErrorEvent(e:Event = null):void		{			_isLoaded = false;						if(hasEventListener(LoaderEvent.IO_ERROR)) {				dispatchEvent(new LoaderEvent(LoaderEvent.IO_ERROR));			}			else			{				throw new IOError("File was not found or was cancelled incorrectly. (" + getURL() + ")");			}		}		/** @private */		final protected function dispatchSecurityErrorEvent(e:Event = null):void		{			_isLoaded = false;						if(hasEventListener(LoaderEvent.SECURITY_ERROR)) {				dispatchEvent(new LoaderEvent(LoaderEvent.SECURITY_ERROR));			}			else			{				throw new SecurityError("SecurityError occured while attempting to load data from URL " + getURL());			}		}				/** @private */		final protected function dispatchLoadCancelEvent(e:Event = null):void		{			BandwidthProfiler.getInstance().registerByteWaste(_bytesLoadedRegisterHolder);							BandwidthProfiler.getInstance().registerLoadOperationCancelled();							_bytesLoadedRegisterHolder = 0;						if(hasEventListener(LoaderEvent.CANCEL)) dispatchEvent(new LoaderEvent(LoaderEvent.CANCEL));		}		private function bytesTotalPrefetchComplete(e:LoaderEvent):void		{			if(hasEventListener(LoaderEvent.BYTESTOTAL_PREFETCHED)) this.dispatchEvent(new LoaderEvent(LoaderEvent.BYTESTOTAL_PREFETCHED));		}	}}