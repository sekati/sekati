/** * @version 1.1 * @author David Dahlstroem | hello@daviddahlstroem.com * Copyright (C) 2009 David Dahlstroem. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */ package sekati.load {	import sekati.core.Cancelable;	import sekati.core.ICoreInterface;	import sekati.events.LoaderQueueEvent;	import sekati.events.WeakEventDispatcher;	import sekati.load.ILoader;		import flash.events.TimerEvent;	import flash.utils.Timer;		/**	 * Used for loading multiple files in a sequence.	 * 	 * TODO Thourough testing required!	 */		public class LoaderQueue extends WeakEventDispatcher implements ICoreInterface, Cancelable	{						/**		 * Total number of loaders allowed to be in progress at any given time.		 * The number of slots may be changed at any time. Setting the number of slots to zero while the queue is running will		 * prevent the queue from processing loaders further.		 * 		 * @see #openSlots		 */				public var slots:uint;				/** @private */		protected var _loaderMap:Array;				/** @private */		protected var _loadersInQueuePool:Array;				/** @private */		protected var _loadersInProgressPool:Array;				/** @private */		protected var _loadersInCompletePool:Array;						private var _complete:Boolean = false;				private var _loading:Boolean = false;				private var _timer:Timer;				/**		 * LoaderQueue Constructor		 * 		 * @param numSlots Number of open slots in the queue. This may be changed via the <code>LoaderQueue.slots</code> property.		 * 		 * @see #slots		 */				public function LoaderQueue(numSlots:uint = 1)		{			super(this);						slots = numSlots;						_loaderMap = [];						_loadersInProgressPool = [];						_loadersInCompletePool = [];						_loadersInQueuePool = [];						_timer = new Timer(50);						_timer.addEventListener(TimerEvent.TIMER, processQueue);		}		/**		 * Starts the queue.		 * A running queue will actively process loaders and instruct them to load appropriately.		 * 		 * @see #running		 * @see #stop		 */				public function start():void		{			_timer.start();						dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.QUEUE_START));		}				/**		 * Stops the queue.		 * An inactive queue will not instruct loaders to load and will remain in its current state untill resumed.		 * 		 * @see #running		 * @see #start		 */				public function stop():void		{			_timer.stop();						dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.QUEUE_STOP));		}				/**		 * Stops the queue and cancels all cancelable loaders. Any loaders canceled are reenqueued and will begin loading		 * when the queue is started again.		 */				public function cancelAndStop():void		{			stop();						cancel();		}				/**		 * Returns an array containing references to all the loaders in the queue.		 */				public function get loaders():Array		{						var a:Array = [];						for(var i:int = 0; i < numLoaders; i++)			{				a.push(_loaderMap[i]);			}						return a;		}				/**		 * Returns an array containing references to loaders currently waiting to be loaded.		 */				public function get loadersQueued():Array		{			var a:Array = [];						for(var i:int = 0;i < _loadersInQueuePool.length; i++)			{				a.push(_loadersInQueuePool[i]);			}						return a;		}				/**		 * Returns an array containing references to loaders currently in load progress.		 */				public function get loadersProgress():Array		{			var a:Array = [];						for(var i:int = 0;i < _loadersInProgressPool.length; i++)			{				a.push(_loadersInProgressPool[i]);			}						return a;		}				/**		 * Returns an array containing references to loaders completed their loading process.		 */				public function get loadersComplete():Array		{			var a:Array = [];						for(var i:int = 0;i < _loadersInCompletePool.length; i++)			{				a.push(_loadersInCompletePool[i]);			}						return a;		}		/**		 * Indicates the current number of open slots.		 * 		 * @see #slots		 */				public function get openSlots():uint		{			return Math.max(slots - _loadersInProgressPool.length, 0);		}				/**		 * Adds a loader to the queue.		 * 		 * @param target Target loader.		 * 		 * @see #removeLoader		 */				public function addLoader(target:AbstractLoader):AbstractLoader		{			_loaderMap.push(target);						_loadersInQueuePool.push(target);						_loadersInQueuePool.sortOn("priority", Array.NUMERIC);						dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.LOADER_ENQUEUED, target));						return target;		}				/**		 * Removes a loader from the queue.		 * 		 * @param target Target loader.		 * @param cancel If set to <code>true</code> and if the loader is cancelable the loading process of the target loader will be canceled.		 * 		 * @see #addLoader		 */				public function removeLoader(target:AbstractLoader, cancel:Boolean = false):void		{			_loaderMap.splice(_loaderMap.indexOf(target), 1);						_loadersInQueuePool.splice(_loadersInQueuePool.indexOf(target), 1);						_loadersInProgressPool.splice(_loadersInProgressPool.indexOf(target), 1);						_loadersInCompletePool.splice(_loadersInCompletePool.indexOf(target), 1);						if(cancel)			{				if(target.loading && target.cancelable) Cancelable(target).cancel();			}						dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.LOADER_DEQUEUED, target));		}				/**		 * Removes a loader from the queue and cancels its loading progress if able.		 * 		 * @param target Target loader.		 */				public function removeAndCancelLoader(target:AbstractLoader):void		{			if(target.cancelable) Cancelable(target).cancel();						removeLoader(target);		}				/**		 * Indicates whether the queue is loaded.		 * A queue is concidered to be loaded when all loaders in the queue are loaded.		 */				public function get loaded():Boolean		{			for(var i:int = 0; i < numLoaders; i++)			{				if(!AbstractLoader(_loaderMap[i]).loaded) return false;					}						return true;		}				/**		 * Indicates the average of all loaders current progress.		 */				public function get progress():Number		{			var bl:uint = 0;						var bt:uint = 0;						for(var i:int = 0; i < numLoaders; i++)			{				var loader:ILoader = _loaderMap[i] as ILoader;								bl += loader.bytesLoaded;								bt += loader.bytesTotal;			}						var ratio:Number = bl / bt;						return (isNaN(ratio)) ? 0 : ratio;		}				/**		 * Indicates the number of loaders contained by the queue		 */				public function get numLoaders():uint		{			return _loaderMap.length;		}				/**		 * Indicates whether the queue is running.		 */				public function get running():Boolean		{			return _timer.running;		}				/**		 * Prefetches the filesize of all contained loaders in the queue. This will make the <code>LoaderQueue.progress</code>		 * indicate a more accurate value if not all loaders in the sequence are loading at any given time.		 * 		 * @see sekati.load.AbstractLoader#prefetchBytesTotal()		 */				public function prefetchBytesTotal():void		{			for(var i:int = 0; i < numLoaders; i++)			{				ILoader(_loaderMap[i]).prefetchBytesTotal();			}		}				/**		 * Cancels all loaders currently in progress.		 * Canceled loaders are reenqueued.		 */				public function cancel():void		{			for(var i:int = 0; i < _loadersInProgressPool.length; i++)			{				var loader:AbstractLoader = _loadersInProgressPool.shift() as AbstractLoader;								if(loader.cancelable)				{						loader.reset();										_loadersInQueuePool.splice(0, 0, loader);					cancel();					return;				}			}		}				/**		 * @inheritDoc		 */		public function destroy():void		{			_loaderMap = null;						_loadersInQueuePool = null;						_loadersInProgressPool = null;						_loadersInCompletePool = null;						_loaderMap = null;						_loadersInProgressPool = null;						_loadersInCompletePool = null;						_loadersInQueuePool = null;						_timer.removeEventListener(TimerEvent.TIMER, processQueue);						_timer = null;		}		private function processQueue(e:TimerEvent):void		{						if(_loadersInQueuePool.length > 0) {								_complete = false;								populateProgressPool();			}			else			{				if(!_complete && _loadersInProgressPool.length == 0)				{						_complete = true;										_loading = false;										dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.QUEUE_COMPLETE));				}			}						if(_loadersInProgressPool.length > 0) processLoadersInProgressPool();		}				private function populateProgressPool():void		{						_loading = true;						var numPopulations:uint = Math.min(_loadersInQueuePool.length, openSlots);						for(var i:int = 0; i < numPopulations; i++)			{				var				loader:AbstractLoader = _loadersInQueuePool.shift();				loader.load();								_loadersInProgressPool.push(loader);								if(hasEventListener(LoaderQueueEvent.LOADER_START)) dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.LOADER_START, loader));			}		}		private function processLoadersInProgressPool():void		{							for(var i:int = 0; i < _loadersInProgressPool.length; i++)			{									var loader:AbstractLoader = _loadersInProgressPool[i] as AbstractLoader;								if(loader.loading && hasEventListener(LoaderQueueEvent.LOADER_PROGRESS)) dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.LOADER_PROGRESS, loader));								if(loader.loaded)				{					_loadersInCompletePool.push(loader);										_loadersInProgressPool.splice(i, 1);										if(hasEventListener(LoaderQueueEvent.LOADER_COMPLETE)) dispatchEvent(new LoaderQueueEvent(LoaderQueueEvent.LOADER_COMPLETE, loader));										processLoadersInProgressPool();										return;				}			}		}			}}