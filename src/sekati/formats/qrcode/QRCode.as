/** * sekati.formats.qrcode.QRCode * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.formats.qrcode {	/**	 * QRCode	 * Level error correction and data sets of parameters.	 * Make () call to create a QR code.	 * GetModuleCount () and isDark () in, QR code to retrieve the data.	 * @see http://qrcode.sourceforge.jp/index.html.en	 * @see http://en.wikipedia.org/wiki/QR_Code	 */	public class QRCode {		private static const PAD0 : int = 0xEC;		private static const PAD1 : int = 0x11;		private var typeNumber : int;		private var modules : Array;		private var moduleCount : int;		private var errorCorrectLevel : int;		private var qrDataList : Array;		/**		 * Model 1, the level of error correction to generate an instance H of the QR code. 		 * @see ErrorCorrectLevel		 */		public function QRCode() {			this.typeNumber = 1;			this.errorCorrectLevel = ErrorCorrectionLevel.H;			this.qrDataList = new Array( );		}		/**		 * Get the model number.		 * @ Return Model 		 */		public function getTypeNumber() : int {			return typeNumber;		}		/**		 * Setting up the model number.		 * @param typeNumber model_number 		 */		public function setTypeNumber(typeNumber : int) : void {			this.typeNumber = typeNumber;		}		/**		 * Get the level of error correction.		 * @ Return error correction level		 * @ See ErrorCorrectLevel 		 */		public function getErrorCorrectLevel() : int {			return errorCorrectLevel;		}		/**		 * Set the level of error correction.		 * @ Param errorCorrectLevel level error correction		 * @ See ErrorCorrectLevel 		 */		public function setErrorCorrectLevel(errorCorrectLevel : int) : void {			this.errorCorrectLevel = errorCorrectLevel;		}		/**		 * Add data to specify the mode.		 * @ Param data data		 * @ Param mode mode		 * @ See Mode 		 */		public function addData(data : String, mode : int = 0) : void {			if (mode == Mode.MODE_AUTO) {				mode = QRUtil.getMode( data );			}			switch(mode) {    				case Mode.MODE_NUMBER :					addQRData( new QRNumber( data ) );					break;    				case Mode.MODE_ALPHA_NUM :					addQRData( new QRAlphaNum( data ) );					break;    				case Mode.MODE_8BIT_BYTE :					addQRData( new QR8BitByte( data ) );					break;    				case Mode.MODE_KANJI :					addQRData( new QRKanji( data ) );					break;    				default :					throw new Error( "mode:" + mode );			}		}		/**		 * To clear the data.		 * <br/> AddData clear the additional data. 		 */		public function clearData() : void {			qrDataList = new Array( );		}		private function addQRData(qrData : QRData) : void {			qrDataList.push( qrData );		}		private function getQRDataCount() : int {			return qrDataList.length;		}		private function getQRData(index : int) : QRData {			return qrDataList[index];		}		/**		 * Gets whether dark modules.		 * @ Param row row (0 to number of modules - 1)		 * @ Param col column (0 - number of modules - 1)		 */ 		public function isDark(row : int, col : int) : Boolean {			if (modules[row][col] != null) {				return modules[row][col];			} else {				return false;			}		}		/**		 * Gets the number of modules. 		 */			public function getModuleCount() : int {			return moduleCount;		}		/**		 * QR code created. 		 */		public function make() : void {			makeImpl( false, getBestMaskPattern( ) );		}		private function getBestMaskPattern() : int {    			var minLostPoint : int = 0;			var pattern : int = 0;    			for (var i : int = 0; i < 8 ; i++) {    				makeImpl( true, i );    				var lostPoint : int = QRUtil.getLostPoint( this );    				if (i == 0 || minLostPoint > lostPoint) {					minLostPoint = lostPoint;					pattern = i;				}			}    			return pattern;		}		/**		 * 		 */		private function makeImpl(test : Boolean, maskPattern : int) : void {    			// Initialize module 			moduleCount = typeNumber * 4 + 17;			modules = new Array( moduleCount );			for (var i : int = 0; i < moduleCount ; i++) {				modules[i] = new Array( moduleCount );			}    			// Set the position detection pattern and the pattern of separation			setupPositionProbePattern( 0, 0 );			setupPositionProbePattern( moduleCount - 7, 0 );			setupPositionProbePattern( 0, moduleCount - 7 );    					setupPositionAdjustPattern( );			setupTimingPattern( );    			setupTypeInfo( test, maskPattern );    			if (typeNumber >= 7) {				setupTypeNumber( test );			}    					var dataArray : Array = qrDataList;			var data : Array = createData( typeNumber, errorCorrectLevel, dataArray );    					mapData( data, maskPattern );		}		private function mapData(data : Array, maskPattern : int) : void {    					var inc : int = -1;			var row : int = moduleCount - 1;			var bitIndex : int = 7;			var byteIndex : int = 0;    					for (var col : int = moduleCount - 1; col > 0 ; col -= 2) {    				if (col == 6) col--;    				while (true) {    									for (var c : int = 0; c < 2 ; c++) {    											if (modules[row][col - c] == null) {    													var dark : Boolean = false;    							if (byteIndex < data.length) {								dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);							}    							var mask : Boolean = QRUtil.getMask( maskPattern, row, col - c );    							if (mask) {								dark = !dark;							}    													modules[row][col - c] = (dark);							bitIndex--;    							if (bitIndex == -1) {								byteIndex++;								bitIndex = 7;							}						}					}    													row += inc;    					if (row < 0 || moduleCount <= row) {						row -= inc;						inc = -inc;						break;					}				}			}		}		/**		 * Sets the alignment pattern 		 */		private function setupPositionAdjustPattern() : void {    			var pos : Array = QRUtil.getPatternPosition( typeNumber );    			for (var i : int = 0; i < pos.length ; i++) {    				for (var j : int = 0; j < pos.length ; j++) {    					var row : int = pos[i];					var col : int = pos[j];    									if (modules[row][col] != null) {						continue;					}    									for (var r : int = -2; r <= 2 ; r++) {    						for (var c : int = -2; c <= 2 ; c++) {    							if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0) ) {								modules[row + r][col + c] = (true);							} else {								modules[row + r][col + c] = (false);							}						}					}				}			}		}		/**		 * Set the pattern for Location 		 */		private function setupPositionProbePattern(row : int, col : int) : void {    			for (var r : int = -1; r <= 7 ; r++) {    				for (var c : int = -1; c <= 7 ; c++) {    					if (row + r <= -1 || moduleCount <= row + r || col + c <= -1 || moduleCount <= col + c) {						continue;					}    										if ( (0 <= r && r <= 6 && (c == 0 || c == 6) ) || (0 <= c && c <= 6 && (r == 0 || r == 6) ) || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {						modules[row + r][col + c] = (true);					} else {						modules[row + r][col + c] = (false);					}				}					}				}		/**		 * Set the timing pattern 		 */		private function setupTimingPattern() : void {			for (var r : int = 8; r < moduleCount - 8 ; r++) {				if (modules[r][6] != null) {					continue;				}				modules[r][6] = (r % 2 == 0);			}			for (var c : int = 8; c < moduleCount - 8 ; c++) {				if (modules[6][c] != null) {					continue;				}				modules[6][c] = (c % 2 == 0);			}		}		/**		 * Setting up the model number 		 */		private function setupTypeNumber(test : Boolean) : void {    			var bits : int = QRUtil.getBCHTypeNumber( typeNumber );			var i : int;			var mod : Boolean;            			for (i = 0; i < 18 ; i++) {				mod = (!test && ( (bits >> i) & 1) == 1);				modules[Math.floor( i / 3 )][i % 3 + moduleCount - 8 - 3] = mod;			}    			for (i = 0; i < 18 ; i++) {				mod = (!test && ( (bits >> i) & 1) == 1);				modules[i % 3 + moduleCount - 8 - 3][Math.floor( i / 3 )] = mod;			}		}		/**		 * Choose a format 		 */		private function setupTypeInfo(test : Boolean, maskPattern : int) : void {    			var data : int = (errorCorrectLevel << 3) | maskPattern;			var bits : int = QRUtil.getBCHTypeInfo( data );			var i : int;			var mod : Boolean;            			// Vertical 			for (i = 0; i < 15 ; i++) {    				mod = (!test && ( (bits >> i) & 1) == 1);    				if (i < 6) {					modules[i][8] = mod;				} else if (i < 8) {					modules[i + 1][8] = mod;				} else {					modules[moduleCount - 15 + i][8] = mod;				}			}    			// Horizontal 			for (i = 0; i < 15 ; i++) {    				mod = (!test && ( (bits >> i) & 1) == 1);    							if (i < 8) {					modules[8][moduleCount - i - 1] = mod;				} else if (i < 9) {					modules[8][15 - i - 1 + 1] = mod;				} else {					modules[8][15 - i - 1] = mod;				}			}    			// Fixed			modules[moduleCount - 8][8] = (!test);		}		private static function createData(typeNumber : int, errorCorrectLevel : int, dataArray : Array) : Array {    					var rsBlocks : Array = RSBlock.getRSBlocks( typeNumber, errorCorrectLevel );			var buffer : BitBuffer = new BitBuffer( );			var i : int;    					for (i = 0; i < dataArray.length ; i++) {				var data : QRData = dataArray[i];				buffer.put( data.getMode( ), 4 );				buffer.put( data.getLength( ), data.getLengthInBits( typeNumber ) );				data.write( buffer );			}    					// Calculate the maximum number of data 			var totalDataCount : int = 0;			for (i = 0; i < rsBlocks.length ; i++) {				totalDataCount += rsBlocks[i].getDataCount( );			}    			if (buffer.getLengthInBits( ) > totalDataCount * 8) {				throw new Error( "code length overflow. (" + buffer.getLengthInBits( ) + ">" + totalDataCount * 8 + ")" );			}    			// End code 			if (buffer.getLengthInBits( ) + 4 <= totalDataCount * 8) {				buffer.put( 0, 4 );			}    			// padding			while (buffer.getLengthInBits( ) % 8 != 0) {				buffer.putBit( false );			}    			// padding			while (true) {    							if (buffer.getLengthInBits( ) >= totalDataCount * 8) {					break;				}				buffer.put( PAD0, 8 );    							if (buffer.getLengthInBits( ) >= totalDataCount * 8) {					break;				}				buffer.put( PAD1, 8 );			}    			return createBytes( buffer, rsBlocks );		}		private static function createBytes(buffer : BitBuffer, rsBlocks : Array) : Array {    			var offset : int = 0;    					var maxDcCount : int = 0;			var maxEcCount : int = 0;    					var dcdata : Array = new Array( rsBlocks.length );			var ecdata : Array = new Array( rsBlocks.length );    					var i : int;			var r : int;    					for (r = 0; r < rsBlocks.length ; r++) {    				var dcCount : int = rsBlocks[r].getDataCount( );				var ecCount : int = rsBlocks[r].getTotalCount( ) - dcCount;    				maxDcCount = Math.max( maxDcCount, dcCount );				maxEcCount = Math.max( maxEcCount, ecCount );    							dcdata[r] = new Array( dcCount );				for (i = 0; i < dcdata[r].length ; i++) {					dcdata[r][i] = 0xff & buffer.getBuffer( )[i + offset];				}				offset += dcCount;    							var rsPoly : Polynomial = QRUtil.getErrorCorrectPolynomial( ecCount );				var rawPoly : Polynomial = new Polynomial( dcdata[r], rsPoly.getLength( ) - 1 );    				var modPoly : Polynomial = rawPoly.mod( rsPoly );				ecdata[r] = new Array( rsPoly.getLength( ) - 1 );				for (i = 0; i < ecdata[r].length ; i++) {					var modIndex : int = i + modPoly.getLength( ) - ecdata[r].length;					ecdata[r][i] = (modIndex >= 0) ? modPoly.getAt( modIndex ) : 0;				}			}    					var totalCodeCount : int = 0;			for (i = 0; i < rsBlocks.length ; i++) {				totalCodeCount += rsBlocks[i].getTotalCount( );			}    			var data : Array = new Array( totalCodeCount );    			var index : int = 0;    			for (i = 0; i < maxDcCount ; i++) {				for (r = 0; r < rsBlocks.length ; r++) {					if (i < dcdata[r].length) {						data[index++] = dcdata[r][i];					}				}			}    			for (i = 0; i < maxEcCount ; i++) {				for (r = 0; r < rsBlocks.length ; r++) {					if (i < ecdata[r].length) {						data[index++] = ecdata[r][i];					}				}			}    			return data;		}		/**		 * Will create a model of minimum QRCode.		 * @ Param data data		 * @ Param errorCorrectLevel level error correction		 */ 		public static function getMinimumQRCode(data : String, errorCorrectLevel : int) : QRCode {    					var mode : int = QRUtil.getMode( data );    			var qr : QRCode = new QRCode( );			qr.setErrorCorrectLevel( errorCorrectLevel );			qr.addData( data, mode );    			var length : int = qr.getQRData( 0 ).getLength( );    			for (var typeNumber : int = 1; typeNumber <= 10 ; typeNumber++) {				if (length <= QRUtil.getMaxLength( typeNumber, mode, errorCorrectLevel ) ) {					qr.setTypeNumber( typeNumber );					break;				}			}    			qr.make( );    			return qr;		}					}}