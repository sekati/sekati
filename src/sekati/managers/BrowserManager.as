/** * sekati.managers.BrowserManager * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.managers {	import sekati.events.BrowserEvent;	import sekati.external.BrowserAddress;	import sekati.log.Logger;	import flash.events.EventDispatcher;	import flash.utils.clearInterval;	import flash.utils.setInterval;		/**	 * <p>BrowserManager provides advanced browser deeplink management to the API via URL Anchor (hash) tag & quasi-page control. Back & Forward browser 	 * button support is provided via a basic polling monitor which allows for a <i>significantly</i> simplified in-line alternative solution to	 * more complex <code>HTML/JavaScript</code> centric solutions such as SWFAddress in exchange for a very small performance trade off. In other words: 	 * this is a pure ActionScript solution to the browser "back button" question.</p>	 * 	 * <p><b>Note</b>: In general, BrowserManager only dispatches <code>BrowserEvent</code> events when the <i>user</i> changes the browser 	 * anchor (thru the back/forward button or manually). The manager <i>intentionally</i> does not dispatch these events when the application itself changes 	 * the anchor via the BrowserManager facility; <i>however</i> if changed via javascript or actionscript wrappers such as <code>BrowserAddress</code> the	 * <code>BrowserEvent</code> will fire.</p>	 * 	 * @example <listing version="3.0">	 * BrowserManager.$.addEventListener( BrowserEvent.ADDRESS_CHANGE, browserAddressChangeHandler );	 * 	 * function browserAddressChangeHandler(e : BrowserEvent ) : void {	 * 		trace( " the browser address changed " );	 * }	 * </listing>	 * 	 * @see sekati.core.Bootstrap	 * @see sekati.core.App#DEEPLINK_ENABLE	 * @see sekati.external.BrowserAddress	 */	public class BrowserManager extends EventDispatcher {		/**		 * The amount of time (in milliseconds) between <code>BrowserAddress</code> checks.		 */		public static const MONITOR_MS : int = 1000;		private static var _instance : BrowserManager;		private var _isMonitoring : Boolean;		private var monitorIntervalId : uint;		private var trackingAnchor : String;		/**		 * BrowserManager Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function BrowserManager( $ : SingletonEnforcer = null) {			if (!$) {				throw new ArgumentError( "sekati.managers.BrowserManager is a Singleton and may only be accessed via its accessor methods: 'getInstance()' or '$'." );				}			Logger.$.status( this, " - BrowserManager Management Initializes ..." );			startMonitor( );		}		/**		 * Singleton Accessor		 * @return BrowserManager		 */		public static function getInstance() : BrowserManager {			if( _instance == null ) _instance = new BrowserManager( new SingletonEnforcer( ) );			return _instance;		}		/**		 * Shorthand singleton accessor getter		 * @return BrowserManager		 */		public static function get $() : BrowserManager {			return BrowserManager.getInstance( );			}		/**		 * Stop monitoring the browser address for changes.		 */		public function stopMonitor() : void {			clearInterval( monitorIntervalId );			_isMonitoring = false;		}		/**		 * Start monitoring the browser address for changes.		 */		public function startMonitor() : void {			monitorIntervalId = setInterval( addressMonitor, MONITOR_MS );			_isMonitoring = true;			updateAnchor( );		}		/**		 * This method is used by <code>BrowserAddress</code> to signal a code-driven anchor 		 * change which <i>should not</i> trigger a <code>BrowserEvent</code> to be fired:		 * only Browser back/forward buttons or manual URL changes should trigger the event. 		 */		public function updateMonitor() : void {			if(isMonitoring) {				stopMonitor( );				updateAnchor( );				startMonitor( );			}		}		private function updateAnchor() : void {			trackingAnchor = BrowserAddress.anchor;		}		/**		 * Check the browser address ever <code>MONITOR_MS</code> and dispatch an event if the address has changed via the user.		 */		private function addressMonitor() : void {			var previousAnchor : String = trackingAnchor;			updateAnchor( );			if(previousAnchor != trackingAnchor) {				dispatchEvent( new BrowserEvent( BrowserEvent.ADDRESS_CHANGE ) );				Logger.$.notice( this, "Detected Browser Anchor Change. Was: " + previousAnchor + ", is: " + trackingAnchor );			}		}		/**		 * Whether the manager is currently monitoring the browser for address changes or not.		 */		public function get isMonitoring() : Boolean {			return _isMonitoring;		}		/**		 * Returns value of the _anchor		 */		public function get anchor() : String {			return BrowserAddress.anchor;		}		/*** @private */		public function set anchor(val : String) : void {			stopMonitor( );			BrowserAddress.anchor = val;			startMonitor( );		}		/**		 * Returns value of property		 */		public function get title() : String {			return BrowserAddress.title;		}		/*** @private */		public function set title(val : String) : void {			BrowserAddress.title = val;		}	}}/** * Internal class is accessible only to this AS file and is used  * as a constructor param to enforce proper Singleton behavior. */internal class SingletonEnforcer {}		