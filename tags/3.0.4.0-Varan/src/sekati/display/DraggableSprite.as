/** * sekati.display.DraggableSprite * @version 1.0.2 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.display {	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import sekati.display.InteractiveSprite;	import sekati.events.FramePulse;		/**	 * DraggableSprite provides a common API construct for drag, drop & throwable sprite objects.	 * @see http://code.google.com/p/as3cards/source/browse/trunk/src/as3cards/visual/DraggableSprite.as	 */	public class DraggableSprite extends InteractiveSprite {		// INTERACTIVITY		protected var friction : Number;		protected var ratio : Number;		protected var isThrowable : Boolean;		// THROWABILITY		protected var isDrag : Boolean;		protected var cx : Number;		protected var cy : Number;		protected var tx : Number;		protected var ty : Number;		protected var xSpeed : Number = 0;		protected var ySpeed : Number = 0;			// BOUNDS		public var bounds : Rectangle;		public var boundLeft : Number;		public var boundRight : Number;		public var boundTop : Number;		public var boundBottom : Number;						/**		 * DraggableSprite Constructor		 * @param bounds 		which the object is draggable.		 * @param throwable 	determines whether the clip has throwable physics.		 * @param friction 		of the throwable physics.		 * @param ratio 		of the throwable physics.		 */		public function DraggableSprite(bounds : Rectangle = null, throwable : Boolean = true, friction : Number = 0.7, ratio : Number = 1.5) {			super( );			isThrowable = throwable;			this.friction = friction;			this.ratio = ratio;			if(bounds) {				this.bounds = bounds;				setBounds( );			}		}		/**		 * @inheritDoc		 */		override protected function configListeners(isAdd : Boolean = false) : void {			super.configListeners( isAdd );			if(isThrowable) {				var listenerMethod : String = (isAdd) ? 'addFrameListener' : 'removeFrameListener';				FramePulse.$[listenerMethod]( frameHandler );			}		}		/**		 * @inheritDoc		 */		override protected function press(e : MouseEvent = null) : void {			super.press( e );			isDrag = true;			this.parent.setChildIndex( this, this.parent.numChildren - 1 );			startDrag( false, bounds );		}		/**		 * @inheritDoc		 */		override protected function release(e : MouseEvent = null) : void {			super.release( e );			stopDrag( );			isDrag = false;			xSpeed = (tx - cx) * ratio;			ySpeed = (ty - cy) * ratio;			//if(dropTarget) trace( "DropTarget: " + dropTarget.name );		}		/**		 * @inheritDoc		 */		override protected function releaseOutside(e : Event = null) : void {			release( );		}		/**		 * Handle throw logic.		 */		protected function frameHandler(e : Event = null) : void {			if (!isDrag) {				cx = x;				cy = y;				tx = cx + xSpeed;				ty = cy + ySpeed;				xSpeed *= friction;				ySpeed *= friction;				if (tx >= boundRight - width || tx <= boundLeft) {					xSpeed *= -friction;					tx = cx;				}				if (ty >= boundBottom - height || ty <= boundTop) {					ySpeed *= -friction;					ty = cy;				}				x = Math.round( tx );				y = Math.round( ty );			} else {				cx = tx;				cy = ty;				tx = x;				ty = y;			}			if (xSpeed < 0.1 && xSpeed > -0.1) xSpeed = 0;			if (ySpeed < 0.1 && ySpeed > -0.1) ySpeed = 0;					}		/**		 * Define the boundaries of the application.		 */		protected function setBounds() : void {			boundLeft = 0;			boundRight = Canvas.stage.stageWidth; 			boundTop = 0;			boundBottom = Canvas.stage.stageHeight - boundTop;				 			bounds = new Rectangle( boundLeft, boundTop, (boundRight - boundLeft - width), (boundBottom - boundTop - height) );		}		/**		 * @inheritDoc		 */		override public function set enabled(b : Boolean) : void {			super.enabled = b;			if(!enabled && isDrag) release( ); 		}	}}