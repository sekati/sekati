/** * sekati.tests.visual.CameraMarkerDetectorTest * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.tests.visual {	import sekati.events.FramePulse;	import sekati.media.CameraDevice;	import sekati.tests.visual.AbstractTestApplication;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.Event;			/**	 * CameraMarkerDetectorTest	 */	public class CameraMarkerDetectorTest extends AbstractTestApplication {		private var camera : CameraDevice;		private var edgeBmp : Bitmap;		private var motionBmp : Bitmap;		private var prevBitmapData : BitmapData;		/**		 * CameraMarkerDetectorTest Constructor		 */		public function CameraMarkerDetectorTest() {			super( );		}		override protected function initEntryPoint() : void {			camera = new CameraDevice( 240, 180 );			addChild( camera );						motionBmp = new Bitmap( );			motionBmp.x = camera.x + camera.width + 8;			motionBmp.y = camera.y;						edgeBmp = new Bitmap( );			edgeBmp.x = camera.x;			edgeBmp.y = camera.y + camera.height + 8;						prevBitmapData = new BitmapData( camera.width, camera.height );						addChildren( camera, motionBmp, edgeBmp );			FramePulse.$.addFrameListener( update );		}		private function update(e : Event) : void {			var x : int;			var y : int;			var p : uint;			var p2 : uint;			var p3 : uint;			var r : int;			var g : int;			var b : int;			var r2 : int;			var g2 : int;			var b2 : int;			var r3 : int;			var g3 : int;			var b3 : int;			var outR : int;			var outG : int;			var outB : int;			var diff : int;					var inputBitmap : BitmapData = new BitmapData( camera.width, camera.height );			inputBitmap.draw( camera );					var newMotionBM : BitmapData = new BitmapData( camera.width, camera.height );			var newEdgeBM : BitmapData = new BitmapData( camera.width, camera.height );					// motion detector			for(y = 0; y < inputBitmap.height ; ++y) {				for(x = 0; x < inputBitmap.width ; ++x) {					p = inputBitmap.getPixel( x, y );					r = (p & 0xFF0000) >> 16;					g = (p & 0x00FF00) >> 8;					b = (p & 0x0000FF);									p2 = prevBitmapData.getPixel( x, y );					r2 = (p2 & 0xFF0000) >> 16;					g2 = (p2 & 0x00FF00) >> 8;					b2 = (p2 & 0x0000FF);									diff = Math.min( 255, (2 * Math.abs( r - r2 ) + 2 * Math.abs( g - g2 ) + 2 * Math.abs( b - b2 )) / 3 );									outR = diff;					outG = diff;					outB = diff;									newMotionBM.setPixel( x, y, (outR << 16) + (outG << 8) + outB );				}			}					// edge detector			for(y = 0; y < inputBitmap.height - 1 ; ++y) {				for(x = 0; x < inputBitmap.width - 1 ; ++x) {					p = inputBitmap.getPixel( x, y );					r = (p & 0xFF0000) >> 16;					g = (p & 0x00FF00) >> 8;					b = (p & 0x0000FF);								p2 = inputBitmap.getPixel( x + 1, y );					r2 = (p2 & 0xFF0000) >> 16;					g2 = (p2 & 0x00FF00) >> 8;					b2 = (p2 & 0x0000FF);									p3 = inputBitmap.getPixel( x, y + 1 );					r3 = (p3 & 0xFF0000) >> 16;					g3 = (p3 & 0x00FF00) >> 8;					b3 = (p3 & 0x0000FF);									diff = Math.min( 255, (2 * Math.abs( r - r2 ) + 2 * Math.abs( g - g2 ) + 2 * Math.abs( b - b2 )) / 3 );					diff += Math.min( 255, (2 * Math.abs( r - r3 ) + 2 * Math.abs( g - g3 ) + 2 * Math.abs( b - b3 )) / 3 );								if( diff > 50 ) 					newEdgeBM.setPixel( x, y, 0xFFFFFF );				else					newEdgeBM.setPixel( x, y, 0x0 );				}			}					motionBmp.bitmapData = newMotionBM;			edgeBmp.bitmapData = newEdgeBM;			prevBitmapData = inputBitmap.clone( ); 		}	}}