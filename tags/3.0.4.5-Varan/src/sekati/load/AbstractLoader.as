/** * sekati.loaders.AbstractLoader * @version 1.0.1 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.load {	import sekati.log.Logger;	import sekati.utils.TypeEnforcer;	import flash.display.Loader;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Sound;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.system.LoaderContext;			/**	 * AbstractLoader provides the core <code>Loader</code> & <code>URLLoader</code> logic for <i>API Loaders</i>.	 */	public class AbstractLoader extends EventDispatcher implements ILoader {		protected var loader : *;		private var LoaderType : Class;		private var listenerPrefix : String;		private var contentSuffix : String;		private var _request : URLRequest;		private var _context : LoaderContext;		private var _bytesTotal : uint;		private var _bytesLoaded : uint;		private var _isLoading : Boolean;		private var _isReady : Boolean;		/**		 * AbstractLoader Constructor		 */		public function AbstractLoader(loaderType : Class, url : String) {			super( );			TypeEnforcer.enforceAbstract( this, AbstractLoader );			_request = new URLRequest( url );			LoaderType = loaderType;			switch (LoaderType) { 				case Loader: 					listenerPrefix = "contentLoaderInfo";					contentSuffix = 'content';					break; 			  				case URLLoader:					listenerPrefix = null;					contentSuffix = 'data';					break;				case Sound:					listenerPrefix = null;					contentSuffix = null; 					break;					 				default:					throw new ArgumentError( "AbstractLoader loaderType Class '" + loaderType + "' not supported." ); 			}		}		/**		 * Configure the adding & removing of loader listeners.		 * @param isAdd 	<code>true</code> adds the listeners, <code>false</code> removes them.		 */		protected function configListeners(isAdd : Boolean = true) : void {			var target : Object = (listenerPrefix) ? loader[listenerPrefix] : loader;			var listener : String = (isAdd) ? "addEventListener" : "removeEventListener";			target[listener]( Event.OPEN, openHandler );			target[listener]( Event.CLOSE, closeHandler );						target[listener]( ProgressEvent.PROGRESS, progressHandler );			target[listener]( IOErrorEvent.IO_ERROR, ioErrorHandler );			target[listener]( SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler );			// define the initializing event:			// - INIT 		== Loader "asset is ready"			// - COMPLETE 	== URLLoader "asset is ready"			var initEvent : String = (LoaderType == Loader) ? Event.INIT : Event.COMPLETE;			target[listener]( initEvent, initHandler );		}		/**		 * <code>Event.OPEN</code> handler.		 */		protected function openHandler(e : Event) : void {			dispatchEvent( new Event( Event.OPEN ) );		}		/**		 * <code>Event.CLOSE</code> handler.		 */		protected function closeHandler(e : Event) : void {			dispatchEvent( new Event( Event.CLOSE ) );		}				/**		 * <code>ProgressEvent.PROGRESS</code> handler.		 */		protected function progressHandler(e : ProgressEvent) : void {			_bytesTotal = e.bytesTotal;			_bytesLoaded = e.bytesLoaded;			dispatchEvent( new ProgressEvent( ProgressEvent.PROGRESS, false, false, _bytesLoaded, _bytesTotal ) );		}		/**		 * <code>Event.INIT</code> handler.		 */		protected function initHandler(e : Event) : void {			// we leave this out: logically it should be false once we are done			// loading but it lends itself to erroneous conditional errors.			//_isLoading = false;			_isReady = true;			configListeners( false );			dispatchEvent( new Event( Event.INIT ) );			AssetLocator.register( this );		}		/**		 * <code>IOErrorEvent.IO_ERROR</code> handler.		 */		protected function ioErrorHandler(e : IOErrorEvent) : void {			genericErrorHandler( e );		}		/**		 * <code>SecurityErrorEvent.SECURITY_ERROR</code> handler.		 */		protected function securityErrorHandler(e : SecurityErrorEvent) : void {			genericErrorHandler( e );		}		/**		 * Generic processor for <code>ErrorEvent</code>'s.		 */				protected function genericErrorHandler(e : ErrorEvent) : void {			dispatchEvent( e.clone( ) );			Logger.$.error( this, "AbstractLoader " + e.type + " encountered: " + e.text );		}		/**		 * Start the loading process.		 */ 		public function load() : void {			loader = new LoaderType( );			configListeners( true );			if(LoaderType is Loader) {				if(!_context) {					_context = new LoaderContext( );					_context.checkPolicyFile = true;												}				loader['load']( request, _context );			} else {				loader['load']( request );			}			_isLoading = true;				}		 		/**		 * Stop the loading process.		 */ 		public function close() : void {			if(_isLoading && !_isReady) {				_isLoading = false;				configListeners( false );				loader['close']( );				loader = new LoaderType( );			}		}			/**		 * Cleanup the <code>AbstractLoader</code>.		 */ 		public function destroy() : void {			close( );			configListeners( false );			loader = null;			AssetLocator.unregister( url );		}					/**		 * Optimized <code>dispatchEvent</code> only dispatches when there are listeners.		 */		override public function dispatchEvent(e : Event) : Boolean {			if (hasEventListener( e.type ) || e.bubbles) {				return super.dispatchEvent( e );			}			return true;		}						/**		 * The loader bytes loaded.		 */		public function get bytesLoaded() : uint {			return _bytesLoaded || 0;		}		/**		 * The loader bytes total.		 */		public function get bytesTotal() : uint {			return _bytesTotal || 0;		}		/**		 * The loader percentile.		 */		public function get percent() : Number {			var p : Number = bytesLoaded / bytesTotal;			if(isNaN( p ) || !isFinite( p )) p = 0;			return p;		}		/**		 * Returns loader context.		 */		public function get context() : LoaderContext {			return _context;		}		/*** @private */		public function set context(c : LoaderContext) : void {			if(LoaderType is Loader) {				loader = c;			} else {				Logger.$.warn( this, LoaderType + " does not support / require a LoaderContext." );			}		}		/**		 * The loader <code>URLRequest</code>.		 */ 		public function get request() : URLRequest {			return _request;		}		/*** @private */ 		public function set request(r : URLRequest) : void {			_request = r;		}					/**		 * The loader url.		 */ 		public function get url() : String {			return _request.url;		}		/*** @private */		public function set url(s : String) : void {			_request.url = s;		}		/**		 * The <i>loosely-typed</i> <code>AbstractLoader</code> content.		 */		protected function get rawContent() : * {			if(_isReady) {				return (!contentSuffix) ? loader : loader[contentSuffix];			} else {				Logger.$.error( this, "The content is not available / has not been fully loaded yet!" );				}		}		/**		 * The loading status of the loader; if <code>true</code> the loader is loading, if <code>false</code> the loader has not started yet.		 */		public function get loading() : Boolean {			return _isLoading;		}		/**		 * The ready status of the loader content; if <code>true</code> the content is loaded, if <code>false</code> the content is not loaded.		 */		public function get ready() : Boolean {			return _isReady;		}	}}