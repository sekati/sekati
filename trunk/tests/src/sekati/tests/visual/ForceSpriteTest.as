/** * sekati.tests.visual.ForceSpriteTest * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.tests.visual {	import sekati.collisions.Collision;	import sekati.collisions.CollisionAngle;	import sekati.collisions.CollisionDetector;	import sekati.display.Canvas;	import sekati.display.ForceSprite;	import sekati.draw.Rect;	import sekati.events.CollisionEvent;	import sekati.math.MathBase;	import sekati.math.Random;	import sekati.tests.visual.AbstractTestApplication;	import sekati.utils.AlignUtil;	import flash.display.Sprite;			/**	 * ForceSpriteTest	 */	public class ForceSpriteTest extends AbstractTestApplication {		public var detector : CollisionDetector;		public static const ALPHA : Number = 0.75;		public static const COLOR : uint = 0x00ffff;		public static const HILITE : uint = 0xff00ff;		public static const SIZE : uint = 50;		public static const AMOUNT : int = 5;		public function ForceSpriteTest() {			super( );		}		override protected function initEntryPoint() : void {			//super.initEntryPoint( );			cacheAsBitmap = true;			var a : Array = new Array( );			var bg : Rect = new Rect( Canvas.stage.stageWidth, Canvas.stage.stageHeight, 0, 0, 0, 0 );			a.push( bg );						var block : Rect = new Rect( 500, 1, 0, 0, 0, 0xff0000 );			AlignUtil.stageAlignCenter( block );			a.push( block );						detector = new CollisionDetector( block );						for (var i : int = 0; i < AMOUNT ; i++) {				var test : ForceSprite = new ForceSprite( rnd( ), rnd( ) );				var size : Number = MathBase.random( SIZE / 3, SIZE * 3 );				if(Random.boolean( ) == true) {					drawRect( test, size );				} else {					drawCircle( test, size );				}				a.push( test );				detector.addItem( test );			}						// add the force sprites			addChildren.apply( this, a );						// start detection			detector.addEventListener( CollisionEvent.COLLISION, collisionHandler );			detector.returnAngleType = CollisionAngle.RADIAN;			detector.startMonitor( );		}		/**		 * Handle collision events!		 */		private function collisionHandler(ev : CollisionEvent) : void {			//Logger.$.info( this, "Collision: " + e );			for (var i : int = 0; i < ev.collisions.length ; i++) {				var collision : Collision = ev.collisions[i];				var obj : ForceSprite = collision.object2 as ForceSprite;				try {					obj.collide( collision.angle );				} catch (e : Error) {				}			}		}		/**		 * Ranged random.		 */		private function rnd(start : Number = 0, finish : Number = 50) : Number {			return MathBase.random( start, finish );		}		/**		 * Draw a rectangle.		 */		public function drawRect(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawRect( 0, 0, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE );			registerShape( s );					}		/**		 * Draw a circle		 */		public function drawCircle(s : Sprite, size : int) : void {			s.graphics.beginFill( COLOR, ALPHA );			s.graphics.drawCircle( size, size, size );			s.graphics.endFill( );			s.x = MathBase.random( 0, Canvas.stage.stageWidth - SIZE * 2 );			registerShape( s );		}		/**		 * Place a registration mark.		 */		public function registerShape(s : Sprite) : void {			s.graphics.beginFill( HILITE, 1 );			s.graphics.drawRect( 0, 0, 5, 5 );			s.graphics.endFill( );		}			}}