/** * sekati.tests.visual.CameraMarkerDetectorTest2 * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.tests.visual {	import flash.display.BitmapData;		import flash.geom.Rectangle;		import sekati.events.FramePulse;	import sekati.media.CameraDevice;	import sekati.tests.visual.AbstractTestApplication;	import flash.events.Event;		/**	 * CameraMarkerDetectorTest2	 */	public class CameraMarkerDetectorTest2 extends AbstractTestApplication {		private var camera : CameraDevice;		// parameters of the webcam image		private var imgRect : Rectangle;		private var imgWidth : int;		private var imgHeight : int;		private var allPix : int;		// start-color for colouring of the regions		static private var fillRegCol : uint = 0x000034;		// for the orientation-method (see edge detection) 		//private var angles : Array = new Array( 360 );		/**		 * CameraMarkerDetectorTest2 Constructor		 */		public function CameraMarkerDetectorTest2() {			super( );		}		override protected function initEntryPoint() : void {			camera = new CameraDevice( 320, 240 );			addChild( camera );						imgWidth = camera.width;			imgHeight = camera.height;			allPix = imgWidth * imgHeight;			imgRect = new Rectangle( 0, 0, imgWidth, imgHeight );			trace( "image width: " + imgWidth + " height: " + imgHeight + " Pixels: " + allPix );			addChildren( camera );			FramePulse.$.addFrameListener( update );		}		private function update(e : Event) : void {		}		public function extractBlackAreas(image : BitmapData, blackThreshold : uint) : void {			for (var yp : int = 0; yp < imgHeight ; yp++) {				for (var xp : int = 0; xp < imgWidth ; xp++) {					// extract via threshold					if (image.getPixel( xp, yp ) <= blackThreshold) {						// write black color in bitmapdata (relevant data)						image.setPixel( xp, yp, 0x000000 );					} else {						// write white color in bitmapdata						image.setPixel( xp, yp, 0xFFFFFF );					}				}			}		}		// better alternative: bmpd.floodFill() (runtime here: about 400 ms! my own floodFill needed 50 ms!)		public function markRegions(image : BitmapData) : int {			// start label with 2, as 0 (black) and 1 (white) are already in the image			var colorLabel : int = 2;			// loop over all pixel values in image			for (var yp : int = 0; yp < image.height ; yp++) {				for (var xp : int = 0; xp < image.width ; xp++) {					// if color-value is detected (here black, background is white)					if (image.getPixel( xp, yp ) == 0) {						// set recent labelColor, the color originates from value of fillRegColor						image.floodFill( xp, yp, fillRegCol * colorLabel );						// one region has been filled with one color, take the next color						colorLabel++;					}					// OPTIONAL: using a byte-array could increase performance				}			}						/* Remove too small areas */			var labelCounter : Array = new Array( colorLabel );			// prepare as int-array			var ti : int = 0;			while (ti < labelCounter.length) { 				// for colorLabel, xpos, ypos, realColor				labelCounter[ti] = [ 4 ]; 				// nill every slot				labelCounter[ti][0] = 0; 				labelCounter[ti][1] = 0; 				labelCounter[ti][2] = 0; 				ti++;			}			for (var yp2 : int = 0; yp2 < image.height ; yp2++) {				for (var xp2 : int = 0; xp2 < image.width ; xp2++) {					// if not white then it is coloured, add 1 to label-counter, save x and y position					if(image.getPixel( xp2, yp2 ) != 0xFFFFFF) {						labelCounter[ (int)( image.getPixel( xp2, yp2 ) / fillRegCol ) ][0]++;						labelCounter[ (int)( image.getPixel( xp2, yp2 ) / fillRegCol ) ][1] = xp2;						labelCounter[ (int)( image.getPixel( xp2, yp2 ) / fillRegCol ) ][2] = yp2;					}				}			}						// region for marker should be at least 30 x 30 = 900, if not remove by filling with white			var to : int = 0;			var cutted : int = 0;			while (to < colorLabel) {				if (labelCounter[to][0] < 900) {					image.floodFill( labelCounter[to][1], // xPos 					labelCounter[to][2], // yPos 					0xFFFFFF );					cutted++;				}				to++;			}			/// trace("Coloured Regions:", colorLabel, "- Regions taken:", colorLabel - cutted);			return colorLabel;		}		// DATA TO MOVE OBJECT on STAGE		public var moveX : int = 0;		public var moveY : int = 0;		// Extract Marker from Image		// array for 0-minX, 1-minY, 2-maxX, 3-maxY [][]		var boundingBoxes : Array = new Array( );		// yellow background to show extract		var ylwBackground : BitmapData = new BitmapData( 320, 240, false, 0xFFFF00 );		var bgRect : Rectangle = new Rectangle( 0, 0, 320, 240 );		var bmpdReg : BitmapData = new BitmapData( 320, 240, false );		// color-label used for our marker		var markerLabel : int = 0;		var lock : Boolean = false;		var regionRectangles : Array = new Array( );		var iColor : uint = 0;		var ui : int = 0;		var colorInE : Array = new Array( );		public function extractMarker(regions : BitmapData, labels : int) : BitmapData {			if(!lock) {				lock = true;				// copy bitmapdata				bmpdReg.draw( regions );				// delete former data from array				regionRectangles.slice( 0, 0 );				colorInE.slice( 0, 0 );				iColor = ui = 0;				// if there is just white + 1 color (here the color of the one & only marker is needed)				for (var iz : int = 0; iz < labels ; iz++) {					iColor = (uint)( fillRegCol * iz );					// get rectangle of recent colour					regionRectangles[iz] = bmpdReg.getColorBoundsRect( 0xFFFFFF, iColor, true );					// false detection equals zero					if( (Rectangle)( regionRectangles[iz] ).width == 0) {						regionRectangles[iz] = 0;					} else {						// bring rectangle to first position of the array						regionRectangles.unshift( regionRectangles[iz] );						/// trace(regionRectangles);						colorInE[ui] = iColor;						ui++;					}				}				// clean the array to only valid Rectangles				var leRe : int = regionRectangles.length;				for (var ij : int = 0; ij < leRe ; ij++) {					// check type, if number (which is "0") or undefined, then remove object from array					if( (typeof regionRectangles[ij] == "number") || ( typeof regionRectangles[ij] == "undefined") ) {						regionRectangles.pop( );					}					else { 						///trace("Valid RECTANGLE:", regionRectangles);					}				}				// prepare the rectangle parameters which will determin and extract the found marker				//var cropWidth : int = 0;				//var cropHeight : int = 0;				var cropRect : Rectangle = new Rectangle( 0, 0, 0, 0 );				var bestCropRect : Rectangle = new Rectangle( 0, 0, 0, 0 );				var ratio : Number = 0;				var bestRatio : Number = 0;				for (var m : int = 0; m < regionRectangles.length ; m++) {					cropRect = (Rectangle)( regionRectangles[m] );					// try to identify the marker which has a square-form, so its width/height should be close to value 1.0					ratio = cropRect.width / cropRect.height;					// get best ratio, which is probably the marker					// note: marker is constrained to have a maximum width of 110 (a marker that is too close to the webcam will not be recognized!)					if ((ratio > bestRatio) && (ratio <= 1.25) && (ratio >= 0.80) && (cropRect.width > 35) && (cropRect.width < 110) && (cropRect.height > 35) ) {						bestRatio = ratio;						// transfer the color						markerLabel = (int)( colorInE[m] );						bestCropRect = cropRect;							/// trace("-- bestRatio:", bestRatio, "-- cropRect:", cropRect);					}				}				/// trace("bestCropRect:", bestCropRect, "MarkerLabel:", markerLabel, "- ColorHex:",((fillRegCol/markerLabel)>>16 & 0xFF).toString(16), ((fillRegCol/markerLabel)>>8 & 0xFF).toString(16), ((fillRegCol/markerLabel) & 0xFF).toString(16));								// clear previous values of bitmapData (just necessary to show it on a clean screen)				ylwBackground.fillRect( bgRect, 0xFFFF00 );								if ( (bestCropRect.width > 0) && (bestCropRect.height > 0) ) {					// this crops the image to the rectangle of our identified marker and 					// draws the bitmapdata of the marker onto the yellow background					ylwBackground.draw( bmpdReg, null, null, null, bestCropRect );										// Transfer data to move football on screen!					// center of marker in relation to center of image					moveX = (int)( (bestCropRect.x + bestCropRect.width / 2) - ylwBackground.width / 2 );					moveY = (int)( (bestCropRect.y + bestCropRect.height / 2) - ylwBackground.height / 2 );				}								// extra: if the marker has no orthognoal position but is rotated 				// there might be white areas at the borders, which we want to be filled by yellow				// just check the half size (60%), so we can check bottom + top together without out-of-bounds				var recentX : int = 0;				for (var xc : int = 0; xc < (int)( bestCropRect.width * 0.6 ) ; xc++) {					recentX = bestCropRect.x + xc;					// search for false areas at the rectangle's TOP border					if (ylwBackground.getPixel( recentX, bestCropRect.y ) == 0xFFFFFF) {						ylwBackground.floodFill( recentX, bestCropRect.y, 0xFFFF00 );					}					// white areas at the BOTTOM border					if (ylwBackground.getPixel( recentX, bestCropRect.y + bestCropRect.height - 1 ) == 0xFFFFFF) {						ylwBackground.floodFill( recentX, bestCropRect.y + bestCropRect.height - 1, 0xFFFF00 );					}				}				// check left + right borders of the rectangle for white areas				var recentY : int = 0;				for (var yck : int = 0; yck < (int)( bestCropRect.height * 0.6 ) ; yck++) {					recentY = bestCropRect.y + yck;					// white areas at the LEFT border					if (ylwBackground.getPixel( bestCropRect.x, recentY ) == 0xFFFFFF) {						ylwBackground.floodFill( bestCropRect.x, recentY, 0xFFFF00 );					}					// white areas at the RIGHT border					if (ylwBackground.getPixel( bestCropRect.x + bestCropRect.width - 1, recentY ) == 0xFFFFFF) {						ylwBackground.floodFill( bestCropRect.x + bestCropRect.width - 1, recentY, 0xFFFF00 );					}				}				// *Code above can surely be optimized, feel free to add your comments to http://media-it.blogspot.com								// unlock our method				lock = false;				// return the extracted bitmapdata				return ylwBackground;			} else {				ylwBackground.fillRect( bgRect, 0xFFFF00 );				return ylwBackground;			}		}		/*********************************************************/		/*** OLD Methods determing boxes + marker id obsolete) ***		// set max min values, to calculate from those, additional coordinates (x) or (y) to save coordinates of corners		for (var i:int = 0; i < labels; i++) {		// init two-dimensional-array		boundingBoxes[i] = [2]; // [labels]		// minX (x,y)		boundingBoxes[i][0] = bmpdReg.width;		boundingBoxes[i][1] = 0;		// minY (x,y)		boundingBoxes[i][2] = 0;		boundingBoxes[i][3] = bmpdReg.height;		// maxX (x,y)		boundingBoxes[i][4] = 0;		boundingBoxes[i][5] = 0;		// maxY (x,y)		boundingBoxes[i][6] = 0;		boundingBoxes[i][7] = 0;		}		// loop over all Pixels 		var recentLabel:int = 0;		for (var yp:int = 0; yp < bmpdReg.height; yp++) {		for (var xp:int = 0; xp < bmpdReg.width; xp++) {		// if not white or black, then it is a coloured region		if ( (bmpdReg.getPixel(xp,yp) != 0xFFFFFF) && (bmpdReg.getPixel(xp,yp) != 0) ) {		// if there are more colours than white and black (or a color) 		if (labels>2) {		// recalculate original colorLabel (2,3,4...)		recentLabel = (int)(bmpdReg.getPixel(xp,yp)/fillRegCol);		}		else {		// there is just one color and white in the array, we need only one boundingBox		recentLabel = 1;		}		// get min and max Values by comparing previous min-max-values		// min X [0,1]		if ( xp < boundingBoxes[recentLabel][0]) {		boundingBoxes[recentLabel][0] = xp;		boundingBoxes[recentLabel][1] = yp;		}// min Y [2,3]		if ( yp < boundingBoxes[recentLabel][3]) {		boundingBoxes[recentLabel][2] = xp;		boundingBoxes[recentLabel][3] = yp;		}// max X [4,5]		if ( xp > boundingBoxes[recentLabel][4]) {		boundingBoxes[recentLabel][4] = xp;		boundingBoxes[recentLabel][5] = yp;		}// max Y [6,7]		if ( yp > boundingBoxes[recentLabel][7]) {		boundingBoxes[recentLabel][6] = xp;		boundingBoxes[recentLabel][7] = yp;		// trace("RECENT LABEL:", recentLabel);		}		}		}		}		// trace min-max-coordinates per color-region		for (var k:int = 0; k < labels; k++) {		trace("\nLabel: " +k+"\nminX x: " + boundingBoxes[k][0] + " y: " + boundingBoxes[k][1] + " - minY x: " + boundingBoxes[k][2] + " y: " + boundingBoxes[k][3]);		trace("maxX x: " + boundingBoxes[k][4] + " y: " + boundingBoxes[k][5] + " - maxY x:" + boundingBoxes[k][6] + " y: " + boundingBoxes[k][7]);		}		// identify the possible marker, get the rectangle to crop 		// var largestArea:int = 0;		var cropWidth:int = 0;		var cropHeight:int = 0;		var cropRect:Rectangle = new Rectangle(0,0,0,0);		var ratio:Number = 0;		var bestRatio:Number = 0;		for (var m:int = 0; m < labels; m++) {		// maxX - minX		cropWidth = boundingBoxes[m][4] - boundingBoxes[m][0];		// if negativ value should occure, set width to zero		if (cropWidth < 0) cropWidth = 0;		// maxY - minY		cropHeight = boundingBoxes[m][7] - boundingBoxes[m][3];		// if negativ value should occure, set height to zero		if (cropHeight < 0) cropHeight = 0;						// try to identify the marker which has a square-form, so its width/height should be about 1		ratio = cropWidth/cropHeight;		// get best ratio, which is probably and hopefully ;) the marker!		if ((ratio > bestRatio) && (ratio <= 1.0) && (cropWidth > 35) && (cropHeight > 35) ) {		bestRatio = ratio;		// if(labels>2) {		// remember label as label of the marker		markerLabel=m;		// } else {markerLabel = 1; }		cropRect.x = boundingBoxes[m][0];		cropRect.y = boundingBoxes[m][3];		cropRect.width = cropWidth;		cropRect.height = cropHeight;														   		trace("-- bestRatio:", bestRatio, "-- cropRect:", cropRect);		}			// optional: crop via largest area of extracted object		var area:int = cropWidth*cropHeight;		if (largestArea < area) {		largestArea = area;		markerLabel=m;		if(labels>2) {		cropRect = new Rectangle(boundingBoxes[m][0], boundingBoxes[m][3], cropWidth, cropHeight);		}		else {		cropRect = new Rectangle(boundingBoxes[m][0], boundingBoxes[m][3], cropWidth, cropHeight);		}		}						}		// trace("\nlargest area", largestArea, "- Label:", markerLabel, "- ColorHex:",((fillRegCol/markerLabel)>>16 & 0xFF).toString(16), ((fillRegCol/markerLabel)>>8 & 0xFF).toString(16), ((fillRegCol/markerLabel) & 0xFF).toString(16));		trace("Marker's Label:", markerLabel, "- ColorHex:",((fillRegCol/markerLabel)>>16 & 0xFF).toString(16), ((fillRegCol/markerLabel)>>8 & 0xFF).toString(16), ((fillRegCol/markerLabel) & 0xFF).toString(16));		trace("crop-rectangle:", cropRect.size, "\n");		// clear previous values of bitmapData (just necessary to show it nicely on the screen without previous data)		// image.fillRect(new Rectangle(cropWidth,cropHeight,image.width-cropWidth, image.height-cropHeight), 0xFFFFFF);		// crop image to rectangle of our identified marker (check if cropRect has been currectly defined)		ylwBackground.fillRect(bgRect, 0xFFFF00);		if ( (cropRect.width > 0) && (cropRect.height > 0) ) {		bmpdReg.copyPixels(bmpdReg,cropRect,new Point(0,0));		// bmpdReg.fillRect(new Rectangle(cropRect.width, cropRect.height, bmpdReg.width-cropRect.width, bmpdReg.height-cropRect.height), 		ylwBackground.draw(bmpdReg,null,null,null,cropRect);		}		lock = false;		return ylwBackground;		}		else {		ylwBackground.fillRect(bgRect, 0xFFFF00);		return ylwBackground;		}*/		/*** END OLD Trash ***/		/*************************************************/				// do iso-data-algorithm to get best threshold (called in main at beginning)		public function getBestThreshold(image : BitmapData) : int {			// create the histogram			createHistogram( image );			// Optimalen Schwellwert bestimmen 			var threshold : int = 128;			while (true) {				if (threshold != optimizeThreshold( threshold ) ) {					threshold = optimizeThreshold( threshold );				} else {					trace( "Optimal Threshold: " + threshold );					break;				}			}			return threshold;		}		var histogram : Array = new Array( 256 );		function createHistogram(image : BitmapData) : void {			var c : int = 0;			var r : int = 0;			var g : int = 0;			var b : int = 0;			for (var yp : int = 0; yp < imgHeight ; yp++) {				for (var xp : int = 0; xp < imgWidth ; xp++) {					// read in color value of pixel					c = image.getPixel( xp, yp );					r = (c & 0xff0000) >> 16;					g = (c & 0x00ff00) >> 8;					b = (c & 0x0000ff);					// grey value of the pixel					var grey : int = 0.299 * r + 0.587 * g + 0.114 * b;					// put value in histogram					histogram[grey] = (int)( histogram[grey] ) + 1;				}			}		}		// recalculate threshold to get an optimized one		private function optimizeThreshold(threshold : int) : * {			var mue : Number = 0, mueLeft : Number = 0, mueRight : Number = 0, numberLeft : Number = 0, numberRight : Number = 0;			var histoVal : int = 0;			for (var j : int = 0; j < histogram.length ; j++) {				histoVal = (int)( histogram[j] );				mue += j * histoVal / allPix;				if (j < threshold) {					mueLeft += j * (histoVal / allPix);					numberLeft += histoVal;				} else {					mueRight += j * (histoVal / allPix);					numberRight += histoVal;				}			}			// normalize mue-values			mueLeft = mueLeft / (numberLeft / allPix);			mueRight = mueRight / (numberRight / allPix);			// assign new threshold			threshold = (int)( (mueLeft + mueRight) / 2 );			//trace("mueLeft: " + mueLeft + " -- mueRight: " + mueRight + " -- Schwellwert: " + threshold);			return threshold;		}		// EDGE Detection		var bmpdEdgeData : BitmapData = new BitmapData( 320, 240, false );		public function edgeDetection(image : BitmapData) : void {			trace( "\n#edge Detection" );			// initialize int-array			//for (var z:int = 0; z<360; z++) {			//	angles[z] = 0;			//}			// variables for edge detection			var pixelTop : uint = 0;			var pixelTopRight : uint = 0;			var pixelRight : uint = 0;			var pixelBottomRight : uint = 0;			var pixelBottom : uint = 0;			var pixelBottomLeft : uint = 0;			var pixelLeft : uint = 0;			var pixelTopLeft : uint = 0;			var gx : uint = 0;			var gy : uint = 0;			// var angle:int = 0;			var colorP : uint = 0;			//var newPixelValue : uint = 0;			// loop through original data and calculate edges			for (var w : int = 0; w < image.width ; w++) {				for (var h : int = 0; h < image.height ; h++) {					pixelTop = (image.getPixel( w, h - 1 ) >> 16 & 0xFF);					pixelTopRight = (image.getPixel( w + 1, h - 1 ) >> 16 & 0xFF);					pixelRight = (image.getPixel( w + 1, h ) >> 16 & 0xFF);					pixelBottomRight = (image.getPixel( w + 1, h + 1 ) >> 16 & 0xFF);					pixelBottom = (image.getPixel( w, h + 1 ) >> 16 & 0xFF);					pixelBottomLeft = (image.getPixel( w - 1, h + 1 ) >> 16 & 0xFF);					pixelLeft = (image.getPixel( w - 1, h ) >> 16 & 0xFF);					pixelTopLeft = (image.getPixel( w - 1, h - 1 ) >> 16 & 0xFF);					// sobel filter horizontal					gx = (pixelTopRight + (pixelRight * 2) + pixelBottomRight) - (pixelTopLeft + (pixelLeft * 2) + pixelBottomLeft);					// sobel filter vertical					gy = (pixelTopLeft + (pixelTop * 2) + pixelTopRight) - (pixelBottomLeft + (pixelBottom * 2 ) + pixelBottomRight);										colorP = Math.abs( gx ) + Math.abs( gy ); //  Math.abs(					// catch values over max and min					if( colorP > 255) colorP = 255;					else if (colorP < 0) colorP = 0;					colorP = (colorP << 16) + (colorP << 8) + (colorP);					// set value 					bmpdEdgeData.setPixel( w, h, colorP );					//* we can get the orientation of every edge by using the following code, maybe somebody has an idea how to use it!					// For Orientation:					// angle = 360 * (Math.atan2(gy, gx)+Math.PI) / ( 2*Math.PI);					// if (angle==360) angle = 0;					// amount of the vector					// var strength:Number = Math.sqrt( Math.pow(gx, 2) + Math.pow(gy, 2) ) / 255;					// wenn Betrag vorhanden, dann interessant					// if ( (strength!=0)&&(angle!=180) ) {					// if ( (gx!=0) || (gy != 0) ) {					//	angles[angle] = (int)(angles[angle]) + 1;					// }					//}				}			}			image.draw( bmpdEdgeData );		}		// binarize the image to black-white-data using the optimal threshold		public function binarize(image : BitmapData, bestThreshold : int) : void {			trace( "best: ", bestThreshold );			for (var yp : int = 0; yp < image.height ; yp++) {				for (var xp : int = 0; xp < image.width ; xp++) {					// read rgb-value of the pixel					var r : int = (image.getPixel( xp, yp ) & 0xff0000) >> 16;					var g : int = (image.getPixel( xp, yp ) & 0x00ff00) >> 8;					var b : int = (image.getPixel( xp, yp ) & 0x0000ff);					var gray : int = 0.299 * r + 0.587 * g + 0.114 * b;					// binarize by the optimal threshold					if (gray < bestThreshold) {						// write value in bitmapdata						image.setPixel( xp, yp, 0x000000 );					} else {						image.setPixel( xp, yp, 0xFFFFFF );					}				}			}		}/* OLD_Method Flood Fill by myself using a queue (too SLOW! compared to the as3 native floodfill)		// Flood Fill (iterative procedure using a queue)		var queue:Array = new Array();		public function markRegionsQUEUE(image:BitmapData):int {			// start label with 2, as 0 (black) and 1 (white) are already in the image			var colorLabel:int = 2;			var n:Node;			// loop over all pixel values in image			for (var yp:int = 0; yp < image.height; yp++) {				for (var xp:int = 0; xp < image.width; xp++) {					// if color-value is detected (here black)					if (image.getPixel(xp,yp)==0) {						// save the coordinates						queue.push(new Node(xp, yp));						// as long as queue is not empty						while (queue.length != 0) {							// get latest Node to process (removes last Node from queue)							n = (Node)(queue.pop());							// check color-value of recent node and if it is within borders							if ( (image.getPixel(n.x,n.y)==0) && (n.x>=0) && (n.x<image.width) && (n.y>=0) && (n.y<image.height) ) {								// set recent labelColor according the Node's coordinates, color originates from value of fillRegColor								image.setPixel(n.x,n.y,fillRegCol*colorLabel);								// remember all the nodes surrounding the recent node								queue.push(new Node(n.x+1,n.y));								queue.push(new Node(n.x+1,n.y+1));								queue.push(new Node(n.x,n.y+1));								queue.push(new Node(n.x-1,n.y+1));								queue.push(new Node(n.x-1,n.y));								queue.push(new Node(n.x-1,n.y-1));								queue.push(new Node(n.x,n.y-1));								queue.push(new Node(n.x+1,n.y-1));							}						}						// one region has been filled with one color, take the next color						colorLabel++;					}				}			}			trace("Coloured-Regions:", colorLabel);			return colorLabel;		}*/		/**** ROTATION of bdEdges ****/		/*	// get Orientation of object and rotate 			var rotateBy:int =  edgeOrientation(cropedImage);			var rotatedBmp:BitmapData = rotateBitmap(rotateBy, cropedImage);						// OPTIONAL: Distortion			// transformToSquare(cropedImage);		} *//*		// rotate the bitmap using a matrix 		function rotateBitmap(degree:int, image:BitmapData):BitmapData {			trace("#rotation","\nrotiere um:", degree, "Grad\n");			var rotateMatrix:Matrix = new Matrix();			MatrixTransformer.rotateAroundExternalPoint(rotateMatrix,image.width/2,image.height/2,degree);			//rotateMatrix.translate(-1 * imgWidth/2, -1 * imgHeight/2);			//rotateMatrix.rotate(-12);			//rotateMatrix.translate(imgWidth/2, imgHeight/2);			// offset necessary for rotation to avoid cutted edges			var offset:int = 20;			bdRotated = new BitmapData(image.width+20, image.height+20, false);			bdRotated.draw(image, rotateMatrix);			return bdRotated;		}		// distortoin of the image		// for this you need the files of: http://www.flashsandy.org/blog/distortimage-in-as3.html		import flash.display.Shape;		import de.firstai.DistortImage; // means: org.flashsandy.display.DistortImage		function transformToSquare(image:BitmapData):void {			trace("#transformation");			var dImg:DistortImage = new DistortImage(image.width, image.height);			// calculate new coordinates, as the image was cropped			boundingBoxes[1][6] -= boundingBoxes[1][0];			boundingBoxes[1][7] -= boundingBoxes[1][3];			boundingBoxes[1][4] -= boundingBoxes[1][0];			boundingBoxes[1][5] -= boundingBoxes[1][3];			boundingBoxes[1][1] -= boundingBoxes[1][3];			boundingBoxes[1][2] -= boundingBoxes[1][0];			boundingBoxes[1][0] -= boundingBoxes[1][0];			boundingBoxes[1][3] -= boundingBoxes[1][3];			trace("boundBox:", boundingBoxes[1]);			var topLeft:Point = new Point(-boundingBoxes[1][1], 0);// stretch up			var topRight:Point = new Point(image.width+(image.width-boundingBoxes[1][2]), 0);// stretch right			var bottomRight:Point = new Point(image.width, image.height+(image.height-boundingBoxes[1][5]));// stretch down			var bottomLeft:Point = new Point(-boundingBoxes[1][6], boundingBoxes[1][7]);// stretch left			trace("distortion using:", topLeft, topRight, bottomRight, bottomLeft);			var spr:Shape = new Shape();			dImg.setTransform(spr.graphics, image, topLeft, topRight, bottomRight, bottomLeft);			// transformed image - display on stage (bottom-right)			spr.y = 2*imgHeight + 10;			spr.x = imgWidth + 10;			addChild(spr);		}				// orientation: the direction of the edges as angles 		function getOrientation():Number {			var counter:int = 0;			for (var i:int = 0; i<360; i++) {				if ((int)(angles[i])!=0) {					// trace(i,"Grad: ", (int)(angles[i]));					counter += (int)(angles[i]);				}			}			// trace("Winkelwerte gesamt:", counter,"\n");			// addiere gleiche Steigungen, sodass Steigungen 0...180 degree			for (var t:int = 180; t<360; t++) {				if ((int)(angles[t])!=0) {					angles[t%180] += (int)(angles[t]);					angles[t] = 0;				}			}			// sorts numbers in array descending, returns highest degrees :)			var indizes:Array = angles.sort(Array.DESCENDING | Array.RETURNINDEXEDARRAY | Array.NUMERIC);			// berechne orientierung des objekts ueber Gewichtung der 7 haeufigsten Winkel			var highDegrees:Number = 0;// meint Winkel von 90 - 180°			var lowDegrees:Number = 0;// meint Winkel von 0 - 89°			var countHigh:Number = 0, countLow:Number = 0;			for (var wi:int = 0; wi<7; wi++) {				if ((int)(angles[indizes[wi]])!=0) {					if ((int)(indizes[wi])<90) {						lowDegrees += ( (int)(indizes[wi])*(int)(angles[indizes[wi]]) );						countLow += (int)(angles[indizes[wi]]);					} else {						highDegrees += ( (int)(indizes[wi])*(int)(angles[indizes[wi]]) );						countHigh += (int)(angles[indizes[wi]]);					}					// trace((int)(indizes[wi]),"Grad x ",(int)(angles[indizes[wi]]));				}			}			var relHigh:Number = highDegrees/countHigh;			var relLow:Number = lowDegrees/countLow;			//trace("gewichteter winkel High:", relHigh);			//trace("gewichteter winkel Low:", relLow);			if (relLow<relHigh-90) {				return relLow + 2;			} else {				return relHigh - 90 + 2;			}		}	}}// apply Blur-Filter// var blurFilter:BlurFilter = new BlurFilter( 32, 32, BitmapFilterQuality.HIGH );// bmpDataA.applyFilter(bmpDataA, imgRect, new Point(0,0), blurFilter );// showNewImage(bmpDataA);/* // apply gaussianfiltervar myGausianFilter:ConvolutionFilter = new ConvolutionFilter(5,5,[ 2,4,5,4,2,  4,9,12,9,4,  5,12,15,12,5,  4,9,12,9,4,  2,4,5,4,2],115);image.applyFilter(imgd,imgRect,new Point(0,0),myGausianFilter);*//* normalize to square (via vertices) - obsolete var bmpTransf:BitmapTransformer = new BitmapTransformer(width,height);// inits for object-transformationvar spCon:Sprite = new Sprite();var imgX:Number=50;var imgY:Number=50;var curV0:Point=new Point(-50,50);var curV1:Point=new Point(imgX+imgWidth,imgY);var curV2:Point=new Point(imgX+imgWidth,imgY+imgHeight);var curV3:Point=new Point(imgX,imgY+imgHeight);bmpTransf.mapBitmapData(srcImage,curV0,curV1,curV2,curV3,spCon);// display on the stage (bottom-right)spCon.x = imgWidth + 10;spCon.y = imgHeight * 2; addChild(spCon);import flash.filters.*;*//* // maybe helpful for further development?You want to fade between one bitmap and another.Solution: Use the pixelDissolve( ) method of the BitmapData class.*//* // for native threshold (for later implementation) destBmp.threshold(srcBmp,             // sourceBitmap                  srcBmp.rect,        // sourceRectangle                  new Point(  ),      // destPoint                  "<",                // operator                  0x00880000,         // threshold                  0x00000000,         // color                  0x00ff0000,         // mask                  true);              // copySource*/	}}