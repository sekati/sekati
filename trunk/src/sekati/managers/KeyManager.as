/** * sekati.managers.KeyManager * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.managers {	import flash.utils.Dictionary;		import flash.display.DisplayObject;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.KeyboardEvent;	import sekati.utils.ArrayPeer;	import sekati.display.Canvas;			/**	 * KeyManager provides an interface for the centralized catching and dispatching of 	 * KeyEvents or via direct coupling of Keyboard events to actions.	 * 	 * TODO - Unfinished: do not implement yet: consider using charCode if not one of the KeyboardEvent keyCodes:	 * String.fromCharCode(event.keyCode)	 * e.g: if (keyEvent.charCode == String("p").charCodeAt(0)) { ... }	 * 	 * @example <listing version="3.0">	 * // initialize the KeyManager:	 * KeyManager.$.init( this.stage ); // if no Stage instance is passed the API Canvas.stage reference is used.	 * 	 * // create a response relationship between a key and method:	 * KeyManager.$.registerKey( keyCode : int, response : Function );	 * 	 * // create a response between a key combo and a method:	 * KeyManager.$.registerKeyCombo( keyCodes : Array, response : Function );	 * </listing>	 * 	 * @see sekati.display.Canvas	 * @see http://livedocs.adobe.com/flex/201/langref/flash/ui/Keyboard.html	 * @see http://livedocs.adobe.com/flex/3/html/help.html?content=Capturing_User_Input_3.html	 */	public class KeyManager extends EventDispatcher {		protected static var _instance : KeyManager;		protected var _enabled : Boolean;		protected var _keyMap : Dictionary;		protected var _keyCombo : Dictionary;		/**		 * KeyManager Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function KeyManager( $ : SingletonEnforcer = null) {			if (!$) {				throw new ArgumentError( "KeyManager is a Singleton and may only be accessed via its accessor methods: 'getInstance()' or '$'." );				}			// initialize the key manager			_keyMap = new Dictionary( true );			_keyCombo = new Dictionary( true );			_enabled = true;			Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyPress );			Canvas.stage.addEventListener( KeyboardEvent.KEY_UP, keyRelease );			Canvas.stage.addEventListener( Event.DEACTIVATE, clearKeys );		}		/**		 * Singleton Accessor		 * @return KeyManager		 */		public static function getInstance() : KeyManager {			if( _instance == null ) _instance = new KeyManager( new SingletonEnforcer( ) );			return _instance;		}		/**		 * Shorthand singleton accessor getter		 * @return KeyManager		 */		public static function get $() : KeyManager {			return KeyManager.getInstance( );			}		/**		 * Indicates whether the KeyManager is enabled (<code>true</code>) or disabled (<code>false</code>).		 */		public function get enabled() : Boolean {			return _enabled;		}		/**		 * @private		 */		public function set enabled(b : Boolean) : void {			_enabled = b;		}				// EVENT HANDLERS 				/**		 * Add the key to the <code>keyMap</code>.		 */		protected function keyPress(e : KeyboardEvent = null) : void {			if (!(e.keyCode in _keyMap)) {				trace( "adding keyCode: " + e.keyCode + " | charCode: " + e.charCode );				_keyMap[e.keyCode] = true;			}			processKey( e.keyCode );		}		/**		 * Remove the key from the <code>keyMap</code>.		 */		protected function keyRelease(e : KeyboardEvent = null) : void {			if (e.keyCode in _keyMap) {				trace( "removing keyCode: " + e.keyCode + " | charCode: " + e.charCode );				delete _keyMap[e.keyCode];			}					}		/**		 * Clear the keyMap.		 */		protected function clearKeys(e : Event = null) : void {			_keyMap = new Dictionary( true );		}		/**		 * Check the key press to see if it matches our handlers.		 */		protected function processKey(keyCode : int) : void {			//for(var i:* in _keyCombo) {}			var maxJ : int = _keyCombo.length;						for (var j : int = 0; j < maxJ ; j++) {								var maxI : int = _keyMap.length;				for (var i : int = 0; i < maxI ; i++) {					if (_keyMap[i] == _keyCombo[j][i + 1]) {						if (i == _keyCombo[j].length - 2) {							//dispatchEvent(new KeyComboEvent(KeyComboEvent.KEY_COMBINATION, _keyCombo[j][0]));							return;						}					}else {						break;					}				}			}				}		// HELPERS				/**		 * Reset the Key Combo and Map.		 */		public function reset() : void {			clearKeys( );			_keyCombo = new Dictionary( true );		}		/**		 * Destroy the KeyManager instance.		 */		public function destroy() : void {			Canvas.stage.removeEventListener( KeyboardEvent.KEY_DOWN, keyPress );			Canvas.stage.removeEventListener( KeyboardEvent.KEY_UP, keyRelease );			Canvas.stage.removeEventListener( Event.DEACTIVATE, clearKeys );			_enabled = false;			_keyMap = null;				_keyCombo = null;			_instance = null;					}		/**		 * Returns true or false if the key represented by the		 * keyCode passed is being pressed		 */		public function isDown(keyCode : uint) : Boolean {			return Boolean( keyCode in _keyMap );		}				// TRIGGERS				/**		 * Add a key or key combo.		 * @param label 	the name of the key or key-combo.		 * @param keys 		array of keyCodes that trigger the responder function.		 * @param handler 	the function to be fired upon a complete key match.		 * 		 * @example <listing version="3.0">		 * KeyManager.$.addKeyListener( "run", [Keyboard.CONTROL, Keyboard.ENTER], runProgram );		 * KeyManager.$.addKeyListener( "copy", [Keyboard.CONTROL, Keyboard.C], copyText ); 		 * </listing>		 */		public function addKeyListener(label : String, keys : Array, handler : Function) : void {			if (!(handler in _keyCombo)) {				//var sortedKeys : Array = keys.sort( Array.NUMERIC );				_keyCombo[handler] = keys.sort( Array.NUMERIC );						}			/*			if (!(label in _keyCombo)) {				//var sortedKeys : Array = keys.sort( Array.NUMERIC );				_keyCombo[label] = { handler:handler, keys:keys };			}			 */		}		/**		 * Remove a key or key combo.		 * @param label 	the name of the key or key-combo		 * @param handler 	the function to be fired upon a complete key match.		 * 		 * @example <listing version="3.0">		 * KeyManager.$.removeKeyListener( "run", runProgram );		 * KeyManager.$.removeKeyListener( "copy", copyText ); 		 * </listing>		 */		public function removeKeyListener(handler : Function) : void {			if (handler in _keyCombo) {				delete _keyCombo[handler];			}			/*			if (label in _keyCombo) {				delete _keyCombo[label];			}				 */					}	}}/** * Internal class is accessible only to this AS file and is used  * as a constructor param to enforce proper Singleton behavior. */internal class SingletonEnforcer {}		