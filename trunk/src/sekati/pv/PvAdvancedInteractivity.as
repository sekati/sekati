/** * sekati.pv.PvAdvancedInteractivity * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.pv {	import sekati.pv.PaperBase;	import org.papervision3d.materials.BitmapFileMaterial;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.events.InteractiveScene3DEvent;	import org.papervision3d.objects.primitives.Cube;	/**	 * PvBasicInteractivity	 */	public class PvAdvancedInteractivity extends PaperBase {		private var frontMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test0.jpg" );		private var backMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test1.jpg" );		private var leftMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test2.jpg" );		private var rightMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test3.jpg" );		private var topMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test4.jpg" );		private var bottomMaterial : BitmapFileMaterial = new BitmapFileMaterial( "../deploy/assets/test5.jpg" );		private var targetrotationX : Number = 0;		private var targetrotationY : Number = 0;		private var targetrotationZ : Number = 0;		private var tweening : Boolean = false;		private var cube : Cube;		/**		 * Constructor		 */		public function PvAdvancedInteractivity() {			super( );			init( 800, 600, true );		}		override protected function init3d() : void {			// We need to be able to identify each side. We'll do this			// by asssigning names to each material. During this process			// we'll also make the materials interactive.			frontMaterial.interactive = true;			frontMaterial.name = "front";			backMaterial.interactive = true;			backMaterial.name = "back";			leftMaterial.interactive = true;			leftMaterial.name = "left";			rightMaterial.interactive = true;			rightMaterial.name = "right";			topMaterial.interactive = true;			topMaterial.name = "top";			bottomMaterial.interactive = true;			bottomMaterial.name = "bottom";			// ---------------------------------------------			cube = new Cube( new MaterialsList( {              front: frontMaterial, back: backMaterial, left: leftMaterial, right: rightMaterial, top: topMaterial, bottom: bottomMaterial              } ), 500, 500, 500, 3, 3, 3 );			cube.addEventListener( InteractiveScene3DEvent.OBJECT_PRESS, onPress );			_activeScene.addChild( cube );		}		private function onPress( e : InteractiveScene3DEvent ) : void {			// If the cube has been moved to the front:			if (tweening) {				// Let it rotate again				tweening = false;			}else {				// Find which rotation we need to be able to see				// the face image:				switch(e.face3d.material.name) {					case "front":						targetrotationX = 0;						targetrotationY = 180;						targetrotationZ = 0;						tweening = true;						break;					case "back":						targetrotationX = 0;						targetrotationY = 0;						targetrotationZ = 0;						tweening = true;						break;					case "left":						targetrotationX = 0;						targetrotationY = -90;						targetrotationZ = 0;						tweening = true;						break;					case "right":						targetrotationX = 0;						targetrotationY = 90;						targetrotationZ = 0;						tweening = true;						break;					case "top":						targetrotationX = 90;						targetrotationY = 0;						targetrotationZ = 0;						tweening = true;						break;					case "bottom":						targetrotationX = -90;						targetrotationY = 0;						targetrotationZ = 180;						tweening = true;						break;				}			}		}		override protected function processFrame() : void {			if (tweening) {				// If a face has been clicked				if (_activeCamera.zoom < 6.8) {					// If the camera isn't zoomed enough then zoom in a bit more:					_activeCamera.zoom += Math.sqrt( 6.8 - _activeCamera.zoom ) / 5;				}             				// Test each rotation and rotate it towards the target rotation:				// X axis:				if (cube.rotationX < targetrotationX) {					cube.rotationX += Math.sqrt( targetrotationX - cube.rotationX );					cube.rotationX = Math.round( cube.rotationX );				}else if (cube.rotationX > targetrotationX) {					cube.rotationX -= Math.sqrt( cube.rotationX - targetrotationX );					cube.rotationX = Math.round( cube.rotationX );				}				// Y axis:				if (cube.rotationY < targetrotationY) {					cube.rotationY += Math.sqrt( targetrotationY - cube.rotationY );					cube.rotationY = Math.round( cube.rotationY );				}else if (cube.rotationY > targetrotationY) {					cube.rotationY -= Math.sqrt( cube.rotationY - targetrotationY );					cube.rotationY = Math.round( cube.rotationY );				}				// Z axis:				if (cube.rotationZ < targetrotationZ) {					cube.rotationZ += Math.sqrt( targetrotationZ - cube.rotationZ );					cube.rotationZ = Math.round( cube.rotationZ );				}else if (cube.rotationZ > targetrotationZ) {					cube.rotationZ -= Math.sqrt( cube.rotationZ - targetrotationZ );					cube.rotationZ = Math.round( cube.rotationZ );				}			}else {				// If the camera is zoomed in, it shouldn't be now				if (_activeCamera.zoom > 2) {					// So zoom out a bit.					_activeCamera.zoom -= Math.sqrt( _activeCamera.zoom - 2 ) / 5;				}             				// Rotate the cube a bit:				cube.rotationX += 2;				cube.rotationY += 2;             				// Make sure that we dont "wind up" the rotation				if (cube.rotationX >= 360) cube.rotationX = 0;				if (cube.rotationY >= 360) cube.rotationY = 0;			}		}							}}